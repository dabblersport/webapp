import 'dart:async';

import 'package:dabbler/core/utils/either.dart';
import '../services/social_health_monitoring_service.dart';
import '../services/social_performance_monitoring_service.dart';
import '../services/social_error_tracking_service.dart';
import '../services/social_abuse_detection_service.dart';

/// Mixin for easy integration of social monitoring capabilities
mixin SocialMonitoringMixin {
  // Monitoring services - to be injected
  SocialHealthMonitoringService? get healthMonitoring => _healthMonitoring;
  SocialPerformanceMonitoringService? get performanceMonitoring => _performanceMonitoring;
  SocialErrorTrackingService? get errorTracking => _errorTracking;
  SocialAbuseDetectionService? get abuseDetection => _abuseDetection;

  SocialHealthMonitoringService? _healthMonitoring;
  SocialPerformanceMonitoringService? _performanceMonitoring;
  SocialErrorTrackingService? _errorTracking;
  SocialAbuseDetectionService? _abuseDetection;

  /// Initialize monitoring services
  void initializeMonitoring({
    SocialHealthMonitoringService? healthMonitoring,
    SocialPerformanceMonitoringService? performanceMonitoring,
    SocialErrorTrackingService? errorTracking,
    SocialAbuseDetectionService? abuseDetection,
  }) {
    _healthMonitoring = healthMonitoring;
    _performanceMonitoring = performanceMonitoring;
    _errorTracking = errorTracking;
    _abuseDetection = abuseDetection;
  }

  /// Track a social feature operation with performance monitoring
  Future<T> trackSocialOperation<T>(
    String feature,
    String operation,
    Future<T> Function() operationFunc, {
    String? userId,
    Map<String, dynamic>? metadata,
  }) async {
    String? measurementId;
    
    try {
      // Start performance measurement
      measurementId = performanceMonitoring?.startMeasurement(
        '${feature}_$operation',
        metadata: metadata,
      );

      // Execute the operation
      final result = await operationFunc();

      // End successful measurement
      if (measurementId != null) {
        performanceMonitoring?.endMeasurement(
          measurementId,
          '${feature}_$operation',
          wasSuccessful: true,
          metadata: metadata,
        );
      }

      return result;
    } catch (error, stackTrace) {
      // Track the error
      errorTracking?.trackError(
        feature: feature,
        operation: operation,
        errorType: error.runtimeType.toString(),
        errorMessage: error.toString(),
        stackTrace: stackTrace.toString(),
        context: metadata,
        userId: userId,
        severity: _determineErrorSeverity(error),
      );

      // End failed measurement
      if (measurementId != null) {
        performanceMonitoring?.endMeasurement(
          measurementId,
          '${feature}_$operation',
          wasSuccessful: false,
          errorType: error.runtimeType.toString(),
          metadata: metadata,
        );
      }

      rethrow;
    }
  }

  /// Track user action for abuse detection
  void trackUserAction({
    required String userId,
    required String action,
    required String targetType,
    String? targetId,
    String? content,
    Map<String, dynamic>? metadata,
  }) {
    abuseDetection?.recordUserAction(
      userId: userId,
      action: action,
      targetType: targetType,
      targetId: targetId,
      content: content,
      metadata: metadata,
    );
  }

  /// Process abuse report
  Future<Either<String, String>> processAbuseReport({
    required String reporterId,
    required String reportedUserId,
    required String reportType,
    required String description,
    String? contentId,
    Map<String, dynamic>? evidence,
  }) async {
    if (abuseDetection == null) {
      return const Left('Abuse detection service not initialized');
    }

    return await abuseDetection!.processAbuseReport(
      reporterId: reporterId,
      reportedUserId: reportedUserId,
      reportType: reportType,
      description: description,
      contentId: contentId,
      evidence: evidence,
    );
  }

  /// Determine error severity based on error type
  ErrorSeverity _determineErrorSeverity(dynamic error) {
    final errorString = error.toString().toLowerCase();
    
    if (errorString.contains('authentication') ||
        errorString.contains('unauthorized') ||
        errorString.contains('security')) {
      return ErrorSeverity.critical;
    }
    
    if (errorString.contains('network') ||
        errorString.contains('timeout') ||
        errorString.contains('connection')) {
      return ErrorSeverity.high;
    }
    
    if (errorString.contains('validation') ||
        errorString.contains('format') ||
        errorString.contains('parsing')) {
      return ErrorSeverity.medium;
    }
    
    return ErrorSeverity.low;
  }
}

/// Helper class for easy social monitoring integration
class SocialMonitoringHelper {
  final SocialPerformanceMonitoringService? _performanceMonitoring;
  final SocialErrorTrackingService? _errorTracking;
  final SocialAbuseDetectionService? _abuseDetection;

  const SocialMonitoringHelper({
    SocialHealthMonitoringService? healthMonitoring,
    SocialPerformanceMonitoringService? performanceMonitoring,
    SocialErrorTrackingService? errorTracking,
    SocialAbuseDetectionService? abuseDetection,
  })  : _performanceMonitoring = performanceMonitoring,
        _errorTracking = errorTracking,
        _abuseDetection = abuseDetection;

  /// Track post creation
  Future<T> trackPostCreation<T>(
    Future<T> Function() createPostFunc, {
    required String userId,
    String? content,
    Map<String, dynamic>? metadata,
  }) async {
    return await _trackOperation(
      createPostFunc,
      feature: 'social_posts',
      operation: 'create_post',
      userId: userId,
      content: content,
      metadata: metadata,
    );
  }

  /// Track comment creation
  Future<T> trackCommentCreation<T>(
    Future<T> Function() createCommentFunc, {
    required String userId,
    required String postId,
    String? content,
    Map<String, dynamic>? metadata,
  }) async {
    return await _trackOperation(
      createCommentFunc,
      feature: 'social_comments',
      operation: 'create_comment',
      userId: userId,
      content: content,
      metadata: {'post_id': postId, ...?metadata},
    );
  }

  /// Track message sending
  Future<T> trackMessageSending<T>(
    Future<T> Function() sendMessageFunc, {
    required String senderId,
    required String receiverId,
    String? content,
    Map<String, dynamic>? metadata,
  }) async {
    return await _trackOperation(
      sendMessageFunc,
      feature: 'social_messaging',
      operation: 'send_message',
      userId: senderId,
      content: content,
      metadata: {'recipient_id': receiverId, ...?metadata},
    );
  }

  /// Track feed loading
  Future<T> trackFeedLoading<T>(
    Future<T> Function() loadFeedFunc, {
    required String userId,
    Map<String, dynamic>? metadata,
  }) async {
    return await _trackOperation(
      loadFeedFunc,
      feature: 'social_feed',
      operation: 'load_feed',
      userId: userId,
      metadata: metadata,
    );
  }

  /// Track user search
  Future<T> trackUserSearch<T>(
    Future<T> Function() searchFunc, {
    required String userId,
    required String searchQuery,
    Map<String, dynamic>? metadata,
  }) async {
    return await _trackOperation(
      searchFunc,
      feature: 'social_search',
      operation: 'search',
      userId: userId,
      content: searchQuery,
      metadata: metadata,
    );
  }

  /// Track friend request
  Future<T> trackFriendRequest<T>(
    Future<T> Function() friendRequestFunc, {
    required String fromUserId,
    required String toUserId,
    Map<String, dynamic>? metadata,
  }) async {
    // Track user action for abuse detection
    _abuseDetection?.recordUserAction(
      userId: fromUserId,
      action: 'friend_request',
      targetType: 'user',
      targetId: toUserId,
      metadata: metadata,
    );

    return await _trackOperation(
      friendRequestFunc,
      feature: 'social_friends',
      operation: 'friend_request',
      userId: fromUserId,
      metadata: {'target_user_id': toUserId, ...?metadata},
    );
  }

  /// Track media upload
  Future<T> trackMediaUpload<T>(
    Future<T> Function() uploadFunc, {
    required String userId,
    required String mediaType,
    int? fileSize,
    Map<String, dynamic>? metadata,
  }) async {
    return await _trackOperation(
      uploadFunc,
      feature: 'social_media',
      operation: 'upload_media',
      userId: userId,
      metadata: {'file_type': mediaType, 'file_size': fileSize, ...?metadata},
    );
  }

  /// Track like action
  void trackLikeAction({
    required String userId,
    required String postId,
    required bool isLike, // true for like, false for unlike
    Map<String, dynamic>? metadata,
  }) {
    _abuseDetection?.recordUserAction(
      userId: userId,
      action: isLike ? 'like' : 'unlike',
      targetType: 'post',
      targetId: postId,
      metadata: metadata,
    );
  }

  /// Track share action
  void trackShareAction({
    required String userId,
    required String postId,
    required String shareType, // 'direct', 'repost', etc.
    Map<String, dynamic>? metadata,
  }) {
    _abuseDetection?.recordUserAction(
      userId: userId,
      action: 'share',
      targetType: 'post',
      targetId: postId,
      metadata: {
        ...?metadata,
        'share_type': shareType,
      },
    );
  }

  /// Track report submission
  Future<Either<String, String>> trackReportSubmission({
    required String reporterId,
    required String reportedUserId,
    required String reportType,
    required String description,
    String? contentId,
    Map<String, dynamic>? evidence,
  }) async {
    if (_abuseDetection == null) {
      return const Left('Abuse detection service not initialized');
    }

    return await _abuseDetection!.processAbuseReport(
      reporterId: reporterId,
      reportedUserId: reportedUserId,
      reportType: reportType,
      description: description,
      contentId: contentId,
      evidence: evidence,
    );
  }

  /// Generic operation tracking
  Future<T> _trackOperation<T>(
    Future<T> Function() operationFunc, {
    required String feature,
    required String operation,
    required String userId,
    String? content,
    Map<String, dynamic>? metadata,
  }) async {
    String? measurementId;
    
    try {
      // Start performance measurement
      measurementId = _performanceMonitoring?.startMeasurement(
        '${feature}_$operation',
        metadata: metadata,
      );

      // Track user action for abuse detection if content is involved
      if (content != null) {
        _abuseDetection?.recordUserAction(
          userId: userId,
          action: operation,
          targetType: feature.replaceAll('social_', ''),
          content: content,
          metadata: metadata,
        );
      }

      // Execute the operation
      final result = await operationFunc();

      // End successful measurement
      if (measurementId != null) {
        _performanceMonitoring?.endMeasurement(
          measurementId,
          '${feature}_$operation',
          wasSuccessful: true,
          metadata: metadata,
        );
      }

      return result;
    } catch (error, stackTrace) {
      // Track the error
      _errorTracking?.trackError(
        feature: feature,
        operation: operation,
        errorType: error.runtimeType.toString(),
        errorMessage: error.toString(),
        stackTrace: stackTrace.toString(),
        context: metadata,
        userId: userId,
        severity: _determineErrorSeverity(error),
      );

      // End failed measurement
      if (measurementId != null) {
        _performanceMonitoring?.endMeasurement(
          measurementId,
          '${feature}_$operation',
          wasSuccessful: false,
          errorType: error.runtimeType.toString(),
          metadata: metadata,
        );
      }

      rethrow;
    }
  }

  /// Determine error severity based on error type
  ErrorSeverity _determineErrorSeverity(dynamic error) {
    final errorString = error.toString().toLowerCase();
    
    if (errorString.contains('authentication') ||
        errorString.contains('unauthorized') ||
        errorString.contains('security')) {
      return ErrorSeverity.critical;
    }
    
    if (errorString.contains('network') ||
        errorString.contains('timeout') ||
        errorString.contains('connection')) {
      return ErrorSeverity.high;
    }
    
    if (errorString.contains('validation') ||
        errorString.contains('format') ||
        errorString.contains('parsing')) {
      return ErrorSeverity.medium;
    }
    
    return ErrorSeverity.low;
  }
}

/// Extension methods for common social operations monitoring
extension SocialOperationTracking on Future<dynamic> {
  /// Track this operation with monitoring services
  Future<T> trackWith<T>(
    SocialMonitoringHelper helper, {
    required String feature,
    required String operation,
    required String userId,
    String? content,
    Map<String, dynamic>? metadata,
  }) async {
    return await helper._trackOperation(
      () async => await this as T,
      feature: feature,
      operation: operation,
      userId: userId,
      content: content,
      metadata: metadata,
    );
  }
}

/// Constants for common social features and operations
class SocialMonitoringConstants {
  // Features
  static const String featurePosts = 'social_posts';
  static const String featureComments = 'social_comments';
  static const String featureMessaging = 'social_messaging';
  static const String featureFeed = 'social_feed';
  static const String featureSearch = 'social_search';
  static const String featureFriends = 'social_friends';
  static const String featureMedia = 'social_media';
  static const String featureProfile = 'social_profile';
  static const String featureNotifications = 'social_notifications';

  // Operations
  static const String opCreate = 'create';
  static const String opRead = 'read';
  static const String opUpdate = 'update';
  static const String opDelete = 'delete';
  static const String opLike = 'like';
  static const String opUnlike = 'unlike';
  static const String opShare = 'share';
  static const String opComment = 'comment';
  static const String opSend = 'send';
  static const String opReceive = 'receive';
  static const String opSearch = 'search';
  static const String opLoad = 'load';
  static const String opUpload = 'upload';
  static const String opDownload = 'download';
  static const String opReport = 'report';
  static const String opBlock = 'block';
  static const String opUnblock = 'unblock';
  static const String opFollow = 'follow';
  static const String opUnfollow = 'unfollow';
  static const String opFriendRequest = 'friend_request';
  static const String opAcceptFriend = 'accept_friend';
  static const String opRejectFriend = 'reject_friend';

  // Target types
  static const String targetPost = 'post';
  static const String targetComment = 'comment';
  static const String targetUser = 'user';
  static const String targetMessage = 'message';
  static const String targetMedia = 'media';
  static const String targetNotification = 'notification';

  // Report types
  static const String reportSpam = 'spam';
  static const String reportHarassment = 'harassment';
  static const String reportInappropriate = 'inappropriate_content';
  static const String reportFakeAccount = 'fake_account';
  static const String reportOther = 'other';

  // Media types
  static const String mediaImage = 'image';
  static const String mediaVideo = 'video';
  static const String mediaAudio = 'audio';
  static const String mediaDocument = 'document';
}
