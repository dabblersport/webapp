import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:geolocator/geolocator.dart';
import 'package:dartz/dartz.dart';
import 'package:dabbler/core/services/analytics/analytics_service.dart';
import 'package:dabbler/core/services/storage_service.dart';
import 'package:dabbler/core/fp/failure.dart';
import '../domain/repositories/social_repository.dart';
import '../../../core/models/user_model.dart';
import 'package:dabbler/data/models/friend_request_model.dart';
import 'social_notifications_service.dart';

/// Service for managing friend relationships and suggestions
class FriendsService {
  final SocialRepository _repository;
  final StorageService _storageService;
  final AnalyticsService _analyticsService;
  final SocialNotificationsService _notificationsService;

  // Caching
  final Map<String, List<UserModel>> _friendsCache = {};
  final Map<String, List<UserModel>> _suggestionsCache = {};
  final Map<String, List<FriendRequestModel>> _requestsCache = {};
  final Map<String, UserModel> _userCache = {};
  
  // Friend suggestion algorithm weights
  static const double _mutualFriendsWeight = 0.4;
  static const double _locationWeight = 0.2;
  static const double _sportsInterestsWeight = 0.25;
  static const double _skillLevelWeight = 0.1;
  static const double _activityWeight = 0.05;

  // Cache expiry durations
  static const Duration _friendsCacheExpiry = Duration(hours: 1);
  static const Duration _suggestionsCacheExpiry = Duration(minutes: 30);
  static const Duration _requestsCacheExpiry = Duration(minutes: 15);

  Timer? _cacheCleanupTimer;

  FriendsService({
    required SocialRepository repository,
    required StorageService storageService,
    required AnalyticsService analyticsService,
    required SocialNotificationsService notificationsService,
  })  : _repository = repository,
        _storageService = storageService,
        _analyticsService = analyticsService,
        _notificationsService = notificationsService {
    _initializeService();
  }

  void _initializeService() {
    _startCacheCleanup();
    _loadCachedData();
  }

  /// Send a friend request
  Future<Either<String, FriendRequestModel>> sendFriendRequest({
    required String targetUserId,
    String? message,
  }) async {
    try {
      // Check if already friends or request exists
      final existingCheck = await _checkExistingRelationship(targetUserId);
      if (existingCheck is Left<String, bool>) {
        return Left(existingCheck.value);
      }

      final result = await _repository.sendFriendRequest(
        targetUserId: targetUserId,
        message: message,
      );

      return result.fold(
        (failure) => Left(failure.toString()),
        (request) {
          if (request == null) {
            return Left('Failed to create friend request');
          }

          // Update cache
          _updateRequestsCache(request, 'sent');

          // Send notification
          _notificationsService.sendFriendRequestNotification(
            request: request,
          );

          // Track analytics
          _analyticsService.trackEvent('friend_request_sent', {
            'target_user_id': targetUserId,
            'has_message': message != null,
          });

          return Right(request);
        },
      );
    } catch (e) {
      debugPrint('Error sending friend request: $e');
      return Left('Failed to send friend request: ${e.toString()}');
    }
  }

  /// Accept a friend request
  Future<Either<String, bool>> acceptFriendRequest({
    required String requestId,
  }) async {
    try {
      final result = await _repository.acceptFriendRequest(requestId);

      return result.fold(
        (failure) => Left(failure.message),
        (success) {
          // Update caches
          _removeFromRequestsCache(requestId);
          _invalidateFriendsCache();
          _invalidateSuggestionsCache();

          // Send notification
          final request = _findRequestById(requestId);
          if (request != null) {
            _notificationsService.sendFriendRequestAcceptedNotification(
              request: request,
            );
          }

          // Track analytics
          _analyticsService.trackEvent('friend_request_accepted', {
            'request_id': requestId,
          });

          return Right(success);
        },
      );
    } catch (e) {
      debugPrint('Error accepting friend request: $e');
      return Left('Failed to accept friend request: ${e.toString()}');
    }
  }

  /// Decline a friend request
  Future<Either<String, bool>> declineFriendRequest({
    required String requestId,
  }) async {
    try {
      final result = await _repository.declineFriendRequest(requestId);

      return result.fold(
        (failure) => Left(failure.message),
        (success) {
          // Update cache
          _removeFromRequestsCache(requestId);

          // Track analytics
          _analyticsService.trackEvent('friend_request_declined', {
            'request_id': requestId,
          });

          return Right(success);
        },
      );
    } catch (e) {
      debugPrint('Error declining friend request: $e');
      return Left('Failed to decline friend request: ${e.toString()}');
    }
  }

  /// Get user's friends list
  Future<Either<String, List<UserModel>>> getFriends({
    String? userId,
    bool forceRefresh = false,
  }) async {
    try {
      final cacheKey = userId ?? 'current_user';

      // Return cached data if available and not forcing refresh
      if (!forceRefresh && _friendsCache.containsKey(cacheKey)) {
        final cachedFriends = _friendsCache[cacheKey]!;
        final cacheTime = _getCacheTimestamp('friends_$cacheKey');
        
        if (cacheTime != null && 
            DateTime.now().difference(cacheTime).compareTo(_friendsCacheExpiry) < 0) {
          return Right(cachedFriends);
        }
      }

      final result = await _repository.getFriends(userId: userId);

      return result.fold(
        (failure) => Left(failure.message),
        (friends) {
          final friendsList = friends as List<UserModel>? ?? [];

          // Update cache
          _friendsCache[cacheKey] = friendsList;
          _setCacheTimestamp('friends_$cacheKey', DateTime.now());

          // Cache individual users
          for (final friend in friendsList) {
            _userCache[friend.id] = friend;
          }

          // Track analytics
          _analyticsService.trackEvent('friends_loaded', {
            'user_id': userId,
            'friends_count': friendsList.length,
            'from_cache': false,
          });

          return Right(friendsList);
        },
      );
    } catch (e) {
      debugPrint('Error getting friends: $e');
      return Left('Failed to load friends: ${e.toString()}');
    }
  }

  /// Get friend requests (received and sent)
  Future<Either<String, Map<String, List<FriendRequestModel>>>> getFriendRequests({
    bool forceRefresh = false,
  }) async {
    try {
      const cacheKey = 'friend_requests';

      // Return cached data if available and not forcing refresh
      if (!forceRefresh && _requestsCache.containsKey(cacheKey)) {
        final cacheTime = _getCacheTimestamp(cacheKey);
        
        if (cacheTime != null && 
            DateTime.now().difference(cacheTime).compareTo(_requestsCacheExpiry) < 0) {
          final received = _requestsCache['received'] ?? [];
          final sent = _requestsCache['sent'] ?? [];
          
          return Right({
            'received': received,
            'sent': sent,
          });
        }
      }

      final result = await _repository.getFriendRequests();

      if (result is Left) {
        return Left(result.value.toString());
      }

      final requests = (result as Right).value as Map<String, List<FriendRequestModel>>? ?? {};
      final received = requests['received'] ?? [];
      final sent = requests['sent'] ?? [];

      // Update cache
      _requestsCache['received'] = received;
      _requestsCache['sent'] = sent;
      _setCacheTimestamp(cacheKey, DateTime.now());

      // Track analytics
      _analyticsService.trackEvent('friend_requests_loaded', {
        'received_count': received.length,
        'sent_count': sent.length,
        'from_cache': false,
      });

      return Right(requests);
    } catch (e) {
      debugPrint('Error getting friend requests: $e');
      return Left('Failed to load friend requests: ${e.toString()}');
    }
  }

  /// Get intelligent friend suggestions
  Future<Either<String, List<UserModel>>> getFriendSuggestions({
    int limit = 20,
    bool forceRefresh = false,
  }) async {
    try {
      const cacheKey = 'friend_suggestions';

      // Return cached data if available and not forcing refresh
      if (!forceRefresh && _suggestionsCache.containsKey(cacheKey)) {
        final cachedSuggestions = _suggestionsCache[cacheKey]!;
        final cacheTime = _getCacheTimestamp(cacheKey);
        
        if (cacheTime != null && 
            DateTime.now().difference(cacheTime).compareTo(_suggestionsCacheExpiry) < 0) {
          return Right(cachedSuggestions.take(limit).toList());
        }
      }

      // Get current user data
      final currentUserResult = await _repository.getCurrentUser();
      if (currentUserResult is Left) {
        return Left(currentUserResult.value.toString());
      }
      final currentUser = (currentUserResult as Right).value as UserModel?;
      if (currentUser == null) {
        return Left('Failed to get current user');
      }

      // Get potential friends from repository
      final potentialResult = await _repository.getPotentialFriends(
        limit: limit * 3, // Get more to allow for better filtering
      );
      
      if (potentialResult is Left) {
        return Left(potentialResult.value.toString());
      }

      final potentialFriends = (potentialResult as Right).value as List<UserModel>? ?? [];

      // Apply advanced suggestion algorithm
      final suggestions = await _calculateFriendSuggestions(
        currentUser: currentUser,
        potentialFriends: potentialFriends,
        limit: limit,
      );

      // Update cache
      _suggestionsCache[cacheKey] = suggestions;
      _setCacheTimestamp(cacheKey, DateTime.now());

      // Cache individual users
      for (final suggestion in suggestions) {
        _userCache[suggestion.id] = suggestion;
      }

      // Track analytics
      _analyticsService.trackEvent('friend_suggestions_loaded', {
        'suggestions_count': suggestions.length,
        'from_cache': false,
      });

      return Right(suggestions);
    } catch (e) {
      debugPrint('Error getting friend suggestions: $e');
      return Left('Failed to load friend suggestions: ${e.toString()}');
    }
  }

  /// Calculate mutual friends between two users
  Future<Either<String, List<UserModel>>> getMutualFriends({
    required String userId,
  }) async {
    try {
      final result = await _repository.getMutualFriends(userId: userId);

      if (result is Left) {
        return Left(result.value.toString());
      }

      final mutualFriends = (result as Right).value as List<UserModel>? ?? [];

      // Cache mutual friends data
      for (final friend in mutualFriends) {
        _userCache[friend.id] = friend;
      }

      return Right(mutualFriends);
    } catch (e) {
      debugPrint('Error getting mutual friends: $e');
      return Left('Failed to get mutual friends: ${e.toString()}');
    }
  }

  /// Remove a friend
  Future<Either<String, bool>> removeFriend({
    required String friendId,
  }) async {
    try {
      final result = await _repository.removeFriend(friendId);

      if (result is Left) {
        return Left(result.value.toString());
      }

      // Update caches
      _invalidateFriendsCache();
      _invalidateSuggestionsCache();

      // Track analytics
      _analyticsService.trackEvent('friend_removed', {
        'friend_id': friendId,
      });

      return Right(true);
    } catch (e) {
      debugPrint('Error removing friend: $e');
      return Left('Failed to remove friend: ${e.toString()}');
    }
  }

  /// Block a user
  Future<Either<String, bool>> blockUser({
    required String userId,
  }) async {
    try {
      final result = await _repository.blockUser(userId);

      if (result is Left) {
        return Left(result.value.toString());
      }

      // Update caches - remove from all friend-related caches
      _removeFromAllCaches(userId);

      // Track analytics
      _analyticsService.trackEvent('user_blocked', {
        'blocked_user_id': userId,
      });

      return Right(true);
    } catch (e) {
      debugPrint('Error blocking user: $e');
      return Left('Failed to block user: ${e.toString()}');
    }
  }

  /// Export friend list
  Future<Either<String, Map<String, dynamic>>> exportFriendList({
    String format = 'json',
  }) async {
    try {
      final friendsResult = await getFriends();
      
      if (friendsResult is Left<String, List<UserModel>>) {
        return Left(friendsResult.value);
      }

      final friends = (friendsResult as Right<String, List<UserModel>>).value;
      
      final exportData = {
        'exported_at': DateTime.now().toIso8601String(),
        'total_friends': friends.length,
        'friends': friends.map((friend) => {
          'id': friend.id,
          'username': friend.firstName ?? 'Unknown',
          'display_name': friend.displayName,
          'profile_image': friend.profileImageUrl,
          'joined_date': friend.createdAt.toIso8601String(),
        }).toList(),
      };

      // Track analytics
      _analyticsService.trackEvent('friend_list_exported', {
        'friends_count': friends.length,
        'export_format': format,
      });

      return Right(exportData);
    } catch (e) {
      debugPrint('Error exporting friend list: $e');
      return Left('Failed to export friend list: ${e.toString()}');
    }
  }

  /// Advanced friend suggestion algorithm
  Future<List<UserModel>> _calculateFriendSuggestions({
    required UserModel currentUser,
    required List<UserModel> potentialFriends,
    required int limit,
  }) async {
    final scoredUsers = <_ScoredUser>[];

    // Get current user's friends for mutual friend calculation
    final friendsResult = await getFriends();
    final currentFriends = friendsResult is Right<String, List<UserModel>> 
        ? (friendsResult).value 
        : <UserModel>[];
    final friendIds = currentFriends.map((f) => f.id).toSet();

    // Get blocked users to exclude
    final blockedUsers = await _getBlockedUserIds();

    for (final user in potentialFriends) {
      // Skip blocked users and existing friends
      if (blockedUsers.contains(user.id) || friendIds.contains(user.id)) {
        continue;
      }

      double score = 0.0;

      // 1. Mutual friends score (40% weight)
      final mutualFriendsResult = await getMutualFriends(userId: user.id);
      final mutualFriendsCount = mutualFriendsResult is Right<String, List<UserModel>>
          ? (mutualFriendsResult).value.length 
          : 0;
      
      score += (mutualFriendsCount / max(currentFriends.length, 1)) * _mutualFriendsWeight;

      // 2. Location proximity score (20% weight) - Skip for now as UserModel doesn't have location
      // if (currentUser.location != null && user.location != null) {
      //   final distance = await _calculateDistance(
      //     currentUser.location!,
      //     user.location!,
      //   );
      //   
      //   // Closer users get higher scores (within 50km gets full score)
      //   final locationScore = max(0.0, (50.0 - distance) / 50.0);
      //   score += locationScore * _locationWeight;
      // }

      // 3. Sports interests similarity (25% weight)
      final sportsScore = _calculateSportsInterestsScore(
        currentUser.sports,
        user.sports,
      );
      score += sportsScore * _sportsInterestsWeight;

      // 4. Skill level compatibility (10% weight) - Skip for now as UserModel doesn't have skill levels
      // final skillScore = _calculateSkillLevelScore(
      //   currentUser.skillLevels ?? {},
      //   user.skillLevels ?? {},
      // );
      // score += skillScore * _skillLevelWeight;

      // 5. Activity level similarity (5% weight) - Skip for now as UserModel doesn't have activity level
      // final activityScore = _calculateActivityScore(
      //   currentUser.activityLevel ?? 'moderate',
      //   user.activityLevel ?? 'moderate',
      // );
      // score += activityScore * _activityWeight;

      scoredUsers.add(_ScoredUser(user: user, score: score));
    }

    // Sort by score descending and return top suggestions
    scoredUsers.sort((a, b) => b.score.compareTo(a.score));
    
    return scoredUsers
        .take(limit)
        .map((scoredUser) => scoredUser.user)
        .toList();
  }

  double _calculateSportsInterestsScore(
    List<String> userInterests,
    List<String> targetInterests,
  ) {
    if (userInterests.isEmpty || targetInterests.isEmpty) {
      return 0.0;
    }

    final commonInterests = userInterests
        .toSet()
        .intersection(targetInterests.toSet());
    
    final totalInterests = userInterests.toSet().union(targetInterests.toSet());
    
    return commonInterests.length / totalInterests.length;
  }

  double _calculateSkillLevelScore(
    Map<String, String> userSkills,
    Map<String, String> targetSkills,
  ) {
    if (userSkills.isEmpty || targetSkills.isEmpty) {
      return 0.0;
    }

    final skillLevels = ['beginner', 'intermediate', 'advanced', 'expert'];
    double totalScore = 0.0;
    int commonSports = 0;

    for (final sport in userSkills.keys) {
      if (targetSkills.containsKey(sport)) {
        final userLevel = skillLevels.indexOf(userSkills[sport] ?? 'beginner');
        final targetLevel = skillLevels.indexOf(targetSkills[sport] ?? 'beginner');
        
        // Similar skill levels get higher scores
        final levelDifference = (userLevel - targetLevel).abs();
        final skillScore = max(0.0, (3 - levelDifference) / 3.0);
        
        totalScore += skillScore;
        commonSports++;
      }
    }

    return commonSports > 0 ? totalScore / commonSports : 0.0;
  }

  double _calculateActivityScore(String userActivity, String targetActivity) {
    final activityLevels = ['low', 'moderate', 'high', 'very_high'];
    final userLevel = activityLevels.indexOf(userActivity);
    final targetLevel = activityLevels.indexOf(targetActivity);
    
    if (userLevel == -1 || targetLevel == -1) {
      return 0.5; // Default score for unknown activity levels
    }

    final difference = (userLevel - targetLevel).abs();
    return max(0.0, (3 - difference) / 3.0);
  }

  Future<double> _calculateDistance(
    Map<String, double> location1,
    Map<String, double> location2,
  ) async {
    try {
      final distance = Geolocator.distanceBetween(
        location1['latitude']!,
        location1['longitude']!,
        location2['latitude']!,
        location2['longitude']!,
      );
      
      return distance / 1000; // Convert to kilometers
    } catch (e) {
      debugPrint('Error calculating distance: $e');
      return double.infinity;
    }
  }

  Future<Either<String, bool>> _checkExistingRelationship(
    String targetUserId,
  ) async {
    try {
      // Check if already friends
      final friendsResult = await getFriends();
      if (friendsResult is Right<String, List<UserModel>>) {
        final friends = (friendsResult).value;
        if (friends.any((f) => f.id == targetUserId)) {
          return Left('Already friends with this user');
        }
      }

      // Check if request already exists
      final requestsResult = await getFriendRequests();
      if (requestsResult is Right<String, Map<String, List<FriendRequestModel>>>) {
        final requests = (requestsResult).value;
        final sentRequests = requests['sent'] ?? [];
        
        if (sentRequests.any((r) => r.toUserId == targetUserId)) {
          return Left('Friend request already sent');
        }
      }

      return Right(true);
    } catch (e) {
      return Left('Failed to check existing relationship: ${e.toString()}');
    }
  }

  Future<Set<String>> _getBlockedUserIds() async {
    try {
      final result = await _repository.getBlockedUsers();
      return result is Right 
          ? ((result as Right).value as List<UserModel>).map((user) => user.id).toSet()
          : <String>{};
    } catch (e) {
      debugPrint('Error getting blocked users: $e');
      return <String>{};
    }
  }

  void _updateRequestsCache(FriendRequestModel request, String type) {
    final requests = _requestsCache[type] ?? [];
    requests.add(request);
    _requestsCache[type] = requests;
  }

  void _removeFromRequestsCache(String requestId) {
    for (final key in _requestsCache.keys) {
      final requests = _requestsCache[key]!;
      requests.removeWhere((r) => r.id == requestId);
    }
  }

  FriendRequestModel? _findRequestById(String requestId) {
    for (final requests in _requestsCache.values) {
      try {
        return requests.firstWhere((r) => r.id == requestId);
      } catch (e) {
        continue;
      }
    }
    return null;
  }

  void _removeFromAllCaches(String userId) {
    // Remove from friends cache
    for (final key in _friendsCache.keys) {
      final friends = _friendsCache[key]!;
      friends.removeWhere((f) => f.id == userId);
    }

    // Remove from suggestions cache
    for (final key in _suggestionsCache.keys) {
      final suggestions = _suggestionsCache[key]!;
      suggestions.removeWhere((s) => s.id == userId);
    }

    // Remove from user cache
    _userCache.remove(userId);

    // Remove from requests cache
    for (final key in _requestsCache.keys) {
      final requests = _requestsCache[key]!;
      requests.removeWhere((r) => 
          r.fromUserId == userId || r.toUserId == userId);
    }
  }

  void _invalidateFriendsCache() {
    _friendsCache.clear();
  }

  void _invalidateSuggestionsCache() {
    _suggestionsCache.clear();
  }

  void _startCacheCleanup() {
    _cacheCleanupTimer = Timer.periodic(
      const Duration(hours: 2),
      (_) => _cleanupCaches(),
    );
  }

  void _cleanupCaches() {
    final now = DateTime.now();

    // Clean expired cache entries
    final expiredFriends = <String>[];
    for (final key in _friendsCache.keys) {
      final cacheTime = _getCacheTimestamp('friends_$key');
      if (cacheTime != null && 
          now.difference(cacheTime).compareTo(_friendsCacheExpiry) > 0) {
        expiredFriends.add(key);
      }
    }
    
    for (final key in expiredFriends) {
      _friendsCache.remove(key);
    }

    debugPrint('Friends cache cleanup completed');
  }

  Future<void> _loadCachedData() async {
    // Load any persistent cache data if needed
    debugPrint('Friends service initialized');
  }

  // Helper methods for cache timestamps
  DateTime? _getCacheTimestamp(String key) {
    try {
      final timestamp = _storageService._storage['cache_timestamp_$key'];
      if (timestamp != null) {
        return DateTime.parse(timestamp);
      }
    } catch (e) {
      debugPrint('Error getting cache timestamp: $e');
    }
    return null;
  }

  void _setCacheTimestamp(String key, DateTime timestamp) {
    try {
      _storageService._storage['cache_timestamp_$key'] = timestamp.toIso8601String();
    } catch (e) {
      debugPrint('Error setting cache timestamp: $e');
    }
  }

  /// Clear all caches
  void clearCaches() {
    _friendsCache.clear();
    _suggestionsCache.clear();
    _requestsCache.clear();
    _userCache.clear();
  }

  /// Dispose service and cleanup
  void dispose() {
    _cacheCleanupTimer?.cancel();
    clearCaches();
  }
}

class _ScoredUser {
  final UserModel user;
  final double score;

  _ScoredUser({required this.user, required this.score});
}
