import 'dart:async';
import 'dart:io';
import 'dart:convert';
import 'dart:math';
// removed unused dart:collection import
import 'package:flutter/foundation.dart';
import 'package:image/image.dart' as img;
import 'package:dabbler/core/utils/either.dart';
import '../../../utils/enums/social_enums.dart'; // For MessageType and MessageStatus enums
import 'package:dabbler/core/services/storage_service.dart';
import 'package:dabbler/core/services/media_upload_service.dart';
import 'package:dabbler/core/services/notification_service.dart';
import '../../../core/models/notification_model.dart';
import 'package:dabbler/data/models/message_model.dart';
import 'package:dabbler/core/services/analytics/analytics_service.dart';
import '../domain/repositories/chat_repository.dart';
import 'package:dabbler/data/models/chat_message_model.dart';
// ...existing code...
import 'real_time_service.dart';

/// Service for managing chat functionality including messages, media, and offline support
class ChatService {
  final ChatRepository _repository;
  final StorageService _storageService;
  final MediaUploadService _mediaUploadService;
  final NotificationService _notificationService;
  final RealTimeService _realTimeService;
  final AnalyticsService _analyticsService;

  // Message queue for offline support
  final Queue<ChatMessageModel> _messageQueue = Queue<ChatMessageModel>();
  final Map<String, ChatMessageModel> _pendingMessages = {};
  final Map<String, List<ChatMessageModel>> _conversationCache = {};
  
  // Read receipts and typing indicators
  final Map<String, Set<String>> _readReceipts = {};
  final Map<String, Set<String>> _typingUsers = {};
  final Map<String, Timer> _typingTimers = {};
  
  // Media compression settings
  static const int _maxImageWidth = 1920;
  static const int _maxImageHeight = 1920;
  static const int _imageQuality = 85;
  static const int _maxVideoSize = 50 * 1024 * 1024; // 50MB
  
  Timer? _backgroundSyncTimer;
  Timer? _cacheCleanupTimer;
  StreamSubscription? _realTimeSubscription;

  ChatService({
    required ChatRepository repository,
    required StorageService storageService,
    required MediaUploadService mediaUploadService,
    required NotificationService notificationService,
    required RealTimeService realTimeService,
    required AnalyticsService analyticsService,
  })  : _repository = repository,
        _storageService = storageService,
        _mediaUploadService = mediaUploadService,
        _notificationService = notificationService,
        _realTimeService = realTimeService,
        _analyticsService = analyticsService {
    _initializeService();
  }

  void _initializeService() {
    _loadOfflineMessages();
    _startBackgroundSync();
    _startCacheCleanup();
    _setupRealTimeListeners();
  }

  /// Send a message with full offline support
  Future<Either<String, ChatMessageModel>> sendMessage({
    required String conversationId,
    required String content,
    MessageType type = MessageType.text,
    List<File>? attachments,
    String? replyToId,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final messageId = _generateMessageId();
      final now = DateTime.now();

      // Create message object
      final message = ChatMessageModel(
        id: messageId,
        conversationId: conversationId,
        senderId: 'current_user', // Replace with actual current user ID
        content: content,
        sentAt: now,
        messageType: type,
        senderName: '', // Will be populated from user profile
        metadata: metadata ?? {},
      );

      // Add to pending messages for immediate UI update
      _pendingMessages[messageId] = message;
      _updateConversationCache(conversationId, message);

      // Handle attachments
      List<String> attachmentUrls = [];
      if (attachments != null && attachments.isNotEmpty) {
        final compressedFiles = await _compressAttachments(attachments);
        
        // Check internet connection
        final hasConnection = await _hasInternetConnection();
        
        if (hasConnection) {
                  final uploadResult = await _uploadAttachments(compressedFiles);
                  if (uploadResult is Left<String, List<String>>) {
                    final err = (uploadResult).value;
                    await _queueMessage(message);
                    return Left('Failed to upload attachments: $err');
                  }
                  attachmentUrls = (uploadResult as Right<String, List<String>>).value;
        } else {
          // Store files locally for later upload
          final localPaths = await _storeAttachmentsLocally(compressedFiles);
          // Note: MediaAttachments should be handled differently in the model
          
          await _queueMessage(message);
          return Right(message);
        }
      }

      // Update message with attachment URLs
      final finalMessage = message.copyWith(
        mediaAttachments: attachmentUrls.map((url) => MediaAttachment(
          id: DateTime.now().millisecondsSinceEpoch.toString(),
          url: url,
          type: _getAttachmentType(url),
          name: url.split('/').last,
          size: 0, // Size not available at this point
        )).toList(),
      );

      // Check internet connection for sending
      final hasConnection = await _hasInternetConnection();
      
      if (!hasConnection) {
        await _queueMessage(finalMessage);
        return Right(finalMessage);
      }

      // Send message via repository
      final result = await _repository.sendMessage(
        conversationId: conversationId,
        content: content,
  messageType: type,
  mediaUrls: attachmentUrls,
  replyToMessageId: replyToId,
        metadata: metadata,
      );

      return result.fold(
        (error) async {
          // Queue for retry if send fails
          await _queueMessage(finalMessage);
          return Left(error.toString());
        },
        (sentMessage) async {
          // Convert ChatMessage entity to ChatMessageModel for service use
          final sentMessageModel = ChatMessageModel(
            id: sentMessage.id,
            conversationId: sentMessage.conversationId,
            senderId: sentMessage.senderId,
            content: sentMessage.content,
            sentAt: sentMessage.sentAt,
            messageType: sentMessage.messageType,
            isEdited: sentMessage.isEdited,
            editedAt: sentMessage.editedAt,
            isDeleted: sentMessage.isDeleted,
            deletedAt: sentMessage.deletedAt,
          );

          // Remove from pending and update cache
          _pendingMessages.remove(messageId);
          _updateConversationCache(conversationId, sentMessageModel);

          // Broadcast via real-time service
          _realTimeService.broadcastMessage(sentMessageModel);

          // Send push notification to other participants
          await _sendMessageNotification(sentMessageModel);

          // Track analytics
              _analyticsService.trackEvent('message_sent', {
            'conversation_id': conversationId,
                'message_type': type.toString().split('.').last,
            'has_attachments': attachments?.isNotEmpty ?? false,
            'is_reply': replyToId != null,
          });

          return Right(sentMessageModel);
        },
      );
    } catch (e) {
      debugPrint('Error sending message: $e');
      return Left('Failed to send message: ${e.toString()}');
    }
  }

  /// Get messages for a conversation with caching
  Future<Either<String, List<ChatMessageModel>>> getMessages({
    required String conversationId,
    int? limit,
    String? beforeMessageId,
    bool forceRefresh = false,
  }) async {
    try {
      final pageLimit = limit ?? 50;

      // Return cached messages if available and not forcing refresh
      if (!forceRefresh && _conversationCache.containsKey(conversationId)) {
        final cachedMessages = _conversationCache[conversationId]!;
        if (cachedMessages.isNotEmpty && beforeMessageId == null) {
          // Add pending messages to cached results
          final allMessages = [
            ...cachedMessages,
            ..._pendingMessages.values
                .where((m) => m.conversationId == conversationId),
          ];
          
          allMessages.sort((a, b) => b.sentAt.compareTo(a.sentAt));
          
          return Right(allMessages.take(pageLimit).toList());
        }
      }

      // Fetch from repository
      final result = await _repository.getMessages(
        conversationId: conversationId,
        limit: pageLimit,
        beforeMessageId: beforeMessageId,
      );

      return result.fold(
        (error) => Left(error.toString()),
        (messages) {
          // Convert ChatMessage entities to ChatMessageModels for caching
          final messageModels = messages.map((msg) => ChatMessageModel(
            id: msg.id,
            conversationId: msg.conversationId,
            senderId: msg.senderId,
            content: msg.content,
            sentAt: msg.sentAt,
            messageType: msg.messageType,
            isEdited: msg.isEdited,
            editedAt: msg.editedAt,
            isDeleted: msg.isDeleted,
            deletedAt: msg.deletedAt,
          )).toList();

          // Update cache
          if (beforeMessageId == null) {
            _conversationCache[conversationId] = messageModels;
          } else {
            // Append to existing cache for pagination
            final existingMessages = _conversationCache[conversationId] ?? [];
            _conversationCache[conversationId] = [...existingMessages, ...messageModels];
          }

          // Mark messages as read
          _markMessagesAsRead(conversationId, messageModels);

          return Right(messageModels);
        },
      );
    } catch (e) {
      debugPrint('Error getting messages: $e');
      return Left('Failed to load messages: ${e.toString()}');
    }
  }

  /// Mark messages as read and sync read receipts
  Future<Either<String, bool>> markAsRead({
    required String conversationId,
    required List<String> messageIds,
  }) async {
    try {
      // Update local read receipts immediately
      for (final messageId in messageIds) {
        _readReceipts[messageId] ??= <String>{};
        _readReceipts[messageId]!.add('current_user');
      }

      // Broadcast read receipts
      _realTimeService.broadcastReadReceipts(
        conversationId: conversationId,
        messageIds: messageIds,
        userId: 'current_user',
      );

      // Sync with server
      // Sync each message read status with the repository
      for (final messageId in messageIds) {
        final res = await _repository.markMessageAsRead(
          messageId: messageId,
          userId: 'current_user',
        );

        final failure = res.fold((f) => f, (_) => null);
        if (failure != null) {
          // Rollback local changes for messages we attempted
          for (final mid in messageIds) {
            _readReceipts[mid]?.remove('current_user');
          }
          return Left(failure.toString());
        }
      }

      return const Right(true);
    } catch (e) {
      debugPrint('Error marking messages as read: $e');
      return Left('Failed to mark messages as read: ${e.toString()}');
    }
  }

  /// Start typing indicator
  Future<Either<String, bool>> startTyping({
    required String conversationId,
  }) async {
    try {
      // Add to local typing users
      _typingUsers[conversationId] ??= <String>{};
      _typingUsers[conversationId]!.add('current_user');

      // Cancel existing timer for this conversation
      _typingTimers[conversationId]?.cancel();
      
      // Set auto-stop timer (10 seconds)
      _typingTimers[conversationId] = Timer(
        const Duration(seconds: 10),
        () => stopTyping(conversationId: conversationId),
      );

      // Broadcast typing status
      _realTimeService.broadcastTypingStatus(
        conversationId: conversationId,
        userId: 'current_user',
        isTyping: true,
      );

      // Notify server
  // Use repository typing API
  await _repository.startTyping(conversationId);

      return Right(true);
    } catch (e) {
      debugPrint('Error starting typing: $e');
      return Left('Failed to start typing indicator: ${e.toString()}');
    }
  }

  /// Stop typing indicator
  Future<Either<String, bool>> stopTyping({
    required String conversationId,
  }) async {
    try {
      // Remove from local typing users
      _typingUsers[conversationId]?.remove('current_user');

      // Cancel timer
      _typingTimers[conversationId]?.cancel();

      // Broadcast typing status
      _realTimeService.broadcastTypingStatus(
        conversationId: conversationId,
        userId: 'current_user',
        isTyping: false,
      );

      // Notify server
  // Use repository typing API
  await _repository.stopTyping(conversationId);

      return Right(true);
    } catch (e) {
      debugPrint('Error stopping typing: $e');
      return Left('Failed to stop typing indicator: ${e.toString()}');
    }
  }

  /// Get typing users for a conversation
  Set<String> getTypingUsers(String conversationId) {
    return _typingUsers[conversationId] ?? <String>{};
  }

  /// Get read receipts for a message
  Set<String> getReadReceipts(String messageId) {
    return _readReceipts[messageId] ?? <String>{};
  }

  /// Delete a message
  Future<Either<String, bool>> deleteMessage({
    required String messageId,
    bool deleteForEveryone = false,
  }) async {
    try {
      final result = await _repository.deleteMessage(messageId);

      return result.fold(
        (l) => Left(l.toString()),
        (r) { 
          // On success remove from caches and notify listeners
          _removeMessageFromCache(messageId);
          _pendingMessages.remove(messageId);
          try {
            _realTimeService.broadcastMessageDeletion(messageId, deleteForEveryone);
          } catch (_) {}
          return Right(true);
        },
      );
    } catch (e) {
      debugPrint('Error deleting message: $e');
      return Left('Failed to delete message: ${e.toString()}');
    }
  }

  /// Compress attachments before upload
  Future<List<File>> _compressAttachments(List<File> files) async {
    final compressedFiles = <File>[];

    for (final file in files) {
      try {
        final extension = file.path.toLowerCase().split('.').last;
        
        if (['jpg', 'jpeg', 'png', 'webp'].contains(extension)) {
          // Compress image
          final compressedFile = await _compressImage(file);
          compressedFiles.add(compressedFile);
        } else if (['mp4', 'mov', 'avi'].contains(extension)) {
          // Check video size and compress if needed
          final fileSize = await file.length();
          if (fileSize > _maxVideoSize) {
            // For now, just reject oversized videos
            throw Exception('Video file too large (max ${_maxVideoSize ~/ (1024 * 1024)}MB)');
          }
          compressedFiles.add(file);
        } else {
          // Other file types pass through
          compressedFiles.add(file);
        }
      } catch (e) {
        debugPrint('Error compressing file ${file.path}: $e');
        throw Exception('Failed to process attachment: ${e.toString()}');
      }
    }

    return compressedFiles;
  }

  Future<File> _compressImage(File imageFile) async {
    try {
      final bytes = await imageFile.readAsBytes();
      final image = img.decodeImage(bytes);
      
      if (image == null) {
        throw Exception('Invalid image format');
      }

      // Resize if too large
      img.Image resized = image;
      if (image.width > _maxImageWidth || image.height > _maxImageHeight) {
        resized = img.copyResize(
          image,
          width: image.width > image.height ? _maxImageWidth : null,
          height: image.height > image.width ? _maxImageHeight : null,
        );
      }

      // Encode with compression
      final compressedBytes = img.encodeJpg(resized, quality: _imageQuality);

      // Create new file
  final compressedPath = '${Directory.systemTemp.path}/compressed_${DateTime.now().millisecondsSinceEpoch}.jpg';
      final compressedFile = File(compressedPath);
      await compressedFile.writeAsBytes(compressedBytes);

      return compressedFile;
    } catch (e) {
      debugPrint('Error compressing image: $e');
      rethrow;
    }
  }

  Future<Either<String, List<String>>> _uploadAttachments(
    List<File> files,
  ) async {
    try {
      final uploadFutures = files.map((file) => 
          _mediaUploadService.uploadFile(file));
      
      try {
        final results = await Future.wait(uploadFutures);
        return Right(results);
      } catch (e) {
        return Left(e.toString());
      }
    } catch (e) {
      return Left('Upload error: ${e.toString()}');
    }
  }

  Future<List<String>> _storeAttachmentsLocally(List<File> files) async {
    final localPaths = <String>[];
    
    try {
  final chatDir = Directory.systemTemp;
      
      for (final file in files) {
        final fileName = '${DateTime.now().millisecondsSinceEpoch}_${file.path.split('/').last}';
        final localPath = '${chatDir.path}/$fileName';
        
        await file.copy(localPath);
        localPaths.add(localPath);
      }
    } catch (e) {
      debugPrint('Error storing attachments locally: $e');
    }

    return localPaths;
  }

  Future<void> _queueMessage(ChatMessageModel message) async {
    _messageQueue.add(message);
  // Save offline message to temp storage
  await _saveOfflineMessageToTemp(message);
  }

  Future<void> _loadOfflineMessages() async {
    try {
      final offlineMessages = await _loadOfflineMessagesFromTemp();
      _messageQueue.addAll(offlineMessages);
      debugPrint('Loaded ${_messageQueue.length} offline messages');
    } catch (e) {
      debugPrint('Error loading offline messages: $e');
    }
  }

  void _startBackgroundSync() {
    _backgroundSyncTimer = Timer.periodic(
      const Duration(minutes: 2),
      (_) => _syncOfflineMessages(),
    );
  }

  Future<void> _syncOfflineMessages() async {
    if (_messageQueue.isEmpty) return;

    try {
      final hasConnection = await _hasInternetConnection();
      if (!hasConnection) return;

      final messagesToSync = _messageQueue.toList();

      for (final message in messagesToSync) {
        // Upload any local attachments first
        List<String> attachmentUrls = [];

        if ((message.mediaAttachments.isNotEmpty ?? false)) {
          final localFiles = message.mediaAttachments
              .map((m) => File(m.url))
              .where((file) => file.existsSync())
              .toList();

          if (localFiles.isNotEmpty) {
            final uploadResult = await _uploadAttachments(localFiles);
            final uploadErr = uploadResult.leftOrNull();
            if (uploadErr != null) continue;
            attachmentUrls = uploadResult.rightOrNull() ?? [];
          }
        }

        // Send message
        final result = await _repository.sendMessage(
          conversationId: message.conversationId,
          content: message.content,
          messageType: message.messageType,
          mediaUrls: attachmentUrls,
          replyToMessageId: message.replyTo?.messageId,
          metadata: message.metadata,
        );

        await result.fold(
          (l) async {
            // Keep message in queue for retry
          },
          (syncedMessage) async {
            _messageQueue.remove(message);
            _updateConversationCache(message.conversationId, syncedMessage);
            await _removeOfflineMessageFromTemp(message.id);

            for (final m in message.mediaAttachments ?? []) {
              try {
                final path = m.url;
                await File(path).delete();
              } catch (e) {
                debugPrint('Error deleting local attachment: $e');
              }
            }

            _analyticsService.trackEvent('offline_message_synced', {
              'message_id': syncedMessage.id,
            });
          },
        );
      }
    } catch (e) {
      debugPrint('Error syncing offline messages: $e');
    }
  }

  void _setupRealTimeListeners() {
    // Listen for incoming messages
    _realTimeService.onMessage.listen((message) {
      try {
        final cm = _ensureChatMessageModel(message);
        _updateConversationCache(cm.conversationId, cm);
        _sendMessageNotification(cm);
      } catch (e) {
        debugPrint('Error handling incoming real-time message: $e');
      }
    });

    // Listen for typing indicators
    _realTimeService.onTypingStatus.listen((event) {
      final conversationId = event['conversation_id'] as String;
      final userId = event['user_id'] as String;
      final isTyping = event['is_typing'] as bool;
      
      _typingUsers[conversationId] ??= <String>{};
      
      if (isTyping) {
        _typingUsers[conversationId]!.add(userId);
      } else {
        _typingUsers[conversationId]!.remove(userId);
      }
    });

    // Listen for read receipts
    _realTimeService.onReadReceipts.listen((event) {
      final messageIds = event['message_ids'] as List<String>;
      final userId = event['user_id'] as String;
      
      for (final messageId in messageIds) {
        _readReceipts[messageId] ??= <String>{};
        _readReceipts[messageId]!.add(userId);
      }
    });
  }

  ChatMessageModel _ensureChatMessageModel(Object? message) {
    if (message is ChatMessageModel) return message;
    if (message is MessageModel) {
      return ChatMessageModel(
        id: message.id,
        conversationId: message.conversationId,
        senderId: message.senderId,
        content: message.content,
        sentAt: message.sentAt,
        messageType: message.messageType,
      );
    }

    // Fallback: attempt to parse map
    if (message is Map<String, dynamic>) {
      return ChatMessageModel.fromJson(message);
    }

    throw Exception('Unsupported message type for real-time conversion');
  }

  Future<void> _markMessagesAsRead(
    String conversationId,
    List<ChatMessageModel> messages,
  ) async {
    final unreadMessageIds = messages
        .where((m) => m.senderId != 'current_user')
        .where((m) => !(_readReceipts[m.id]?.contains('current_user') ?? false))
        .map((m) => m.id)
        .toList();

    if (unreadMessageIds.isNotEmpty) {
      await markAsRead(
        conversationId: conversationId,
        messageIds: unreadMessageIds,
      );
    }
  }

  Future<void> _sendMessageNotification(ChatMessageModel message) async {
    if (message.senderId == 'current_user') return;

    try {
      // Create a NotificationModel and add it to the NotificationService
      final notification = NotificationModel(
        id: message.id,
        title: 'New message',
        message: _getNotificationBody(message),
        type: NotificationType.generalUpdate,
        priority: NotificationPriority.high,
        createdAt: DateTime.now(),
        isRead: false,
        data: {
          'type': 'chat_message',
          'conversation_id': message.conversationId,
          'message_id': message.id,
        },
      );

      _notificationService.addNotification(notification);
    } catch (e) {
      debugPrint('Error sending message notification: $e');
    }
  }

  String _getNotificationBody(ChatMessageModel message) {
    switch (message.messageType) {
      case MessageType.image:
        return 'Sent an image';
      case MessageType.video:
        return 'Sent a video';
      case MessageType.audio:
        return 'Sent a voice message';
      case MessageType.file:
        return 'Sent a file';
      default:
        return message.content.length > 50
            ? '${message.content.substring(0, 50)}...'
            : message.content;
    }
  }

  // Offline message helpers using system temp directory (best-effort)
  Future<void> _saveOfflineMessageToTemp(ChatMessageModel message) async {
    final path = '${Directory.systemTemp.path}/offline_message_${message.id}.json';
    try {
      await File(path).writeAsString(jsonEncode(message.toJson()));
    } catch (e) {
      debugPrint('Failed to save offline message to temp: $e');
    }
  }

  Future<List<ChatMessageModel>> _loadOfflineMessagesFromTemp() async {
    final dir = Directory.systemTemp;
    final messages = <ChatMessageModel>[];
    try {
      final files = dir.listSync().where((f) => f.path.contains('offline_message_') && f.path.endsWith('.json'));
      for (final f in files) {
        try {
          final content = await File(f.path).readAsString();
          final Map<String, dynamic> json = jsonDecode(content);
          messages.add(ChatMessageModel.fromJson(json));
        } catch (_) {
          // ignore malformed files
        }
      }
    } catch (e) {
      debugPrint('Failed to load offline messages from temp: $e');
    }
    return messages;
  }

  Future<void> _removeOfflineMessageFromTemp(String messageId) async {
    final path = '${Directory.systemTemp.path}/offline_message_$messageId.json';
    try {
      final file = File(path);
      if (await file.exists()) await file.delete();
    } catch (e) {
      // ignore
    }
  }

  void _updateConversationCache(String conversationId, ChatMessageModel message) {
    _conversationCache[conversationId] ??= [];
    final messages = _conversationCache[conversationId]!;
    
    // Update existing message or add new one
    final index = messages.indexWhere((m) => m.id == message.id);
    if (index >= 0) {
      messages[index] = message;
    } else {
      messages.insert(0, message);
    }
    
    // Keep cache size reasonable
    if (messages.length > 100) {
      _conversationCache[conversationId] = messages.take(100).toList();
    }
  }

  void _removeMessageFromCache(String messageId) {
    for (final conversationId in _conversationCache.keys) {
      final messages = _conversationCache[conversationId]!;
      messages.removeWhere((m) => m.id == messageId);
    }
  }

  void _startCacheCleanup() {
    _cacheCleanupTimer = Timer.periodic(
      const Duration(hours: 2),
      (_) => _cleanupCaches(),
    );
  }

  void _cleanupCaches() {
  // Clean old read receipts
  _readReceipts.removeWhere((messageId, users) {
      // Remove read receipts older than 24 hours
      // This is a simplified cleanup - in production, you'd want more sophisticated logic
      return false; // Keep all for now
    });

    // Clean typing timers
    final expiredTimers = <String>[];
    for (final entry in _typingTimers.entries) {
      if (!entry.value.isActive) {
        expiredTimers.add(entry.key);
      }
    }
    
    for (final key in expiredTimers) {
      _typingTimers.remove(key);
    }

    debugPrint('Chat cache cleanup completed');
  }

  String _generateMessageId() {
    return 'msg_${DateTime.now().millisecondsSinceEpoch}_${Random().nextInt(1000)}';
  }

  Future<bool> _hasInternetConnection() async {
    try {
      final result = await InternetAddress.lookup('google.com');
      return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
    } catch (e) {
      return false;
    }
  }

  /// Clear all caches
  void clearCaches() {
    _conversationCache.clear();
    _readReceipts.clear();
    _typingUsers.clear();
    _pendingMessages.clear();
  }

  /// Determines attachment type from URL
  AttachmentType _getAttachmentType(String url) {
    final extension = url.split('.').last.toLowerCase();
    switch (extension) {
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
      case 'webp':
        return AttachmentType.image;
      case 'mp4':
      case 'avi':
      case 'mov':
      case 'wmv':
        return AttachmentType.video;
      case 'mp3':
      case 'wav':
      case 'aac':
      case 'flac':
        return AttachmentType.audio;
      default:
        return AttachmentType.file;
    }
  }

  /// Dispose service and cleanup
  void dispose() {
    _backgroundSyncTimer?.cancel();
    _cacheCleanupTimer?.cancel();
    _realTimeSubscription?.cancel();
    
    // Cancel all typing timers
    for (final timer in _typingTimers.values) {
      timer.cancel();
    }
    _typingTimers.clear();

    clearCaches();
  }
}

class Queue<T> {
  final List<T> _items = [];

  void add(T item) => _items.add(item);
  void addAll(Iterable<T> items) => _items.addAll(items);
  bool remove(T item) => _items.remove(item);
  T removeFirst() => _items.removeAt(0);
  bool get isEmpty => _items.isEmpty;
  bool get isNotEmpty => _items.isNotEmpty;
  int get length => _items.length;
  List<T> toList() => List<T>.from(_items);
}

