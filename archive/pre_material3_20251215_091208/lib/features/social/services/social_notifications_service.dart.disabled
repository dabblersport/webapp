import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:dabbler/core/utils/either.dart';
import 'package:dabbler/core/services/analytics/analytics_service.dart';
import 'package:dabbler/core/services/notification_service.dart';
import 'package:dabbler/core/services/storage_service.dart';
import 'package:dabbler/data/models/post_model.dart';
import 'package:dabbler/data/models/chat_message_model.dart';
import 'package:dabbler/data/models/message_model.dart';
import 'package:dabbler/data/models/comment_model.dart';
import 'package:dabbler/data/models/friend_request_model.dart';
import 'package:dabbler/data/models/reaction_model.dart';
import 'package:dabbler/data/models/user_model.dart';

/// Service for managing social notifications with smart batching and preferences
class SocialNotificationsService {
  final NotificationService _notificationService;
  final StorageService _storageService;
  final AnalyticsService _analyticsService;

  // Notification batching
  final Map<String, List<_PendingNotification>> _pendingNotifications = {};
  Timer? _batchProcessingTimer;
  static const Duration _batchDelay = Duration(seconds: 10);

  // Notification preferences
  Map<String, dynamic> _notificationPreferences = {};
  
  // Do not disturb settings
  bool _isDndEnabled = false;
  TimeOfDay? _dndStartTime;
  TimeOfDay? _dndEndTime;
  Set<String> _dndDays = {};

  // Notification counters for analytics
  final Map<String, int> _notificationCounts = {};

  // Rate limiting
  final Map<String, DateTime> _lastNotificationTime = {};
  static const Duration _rateLimit = Duration(minutes: 1);

  SocialNotificationsService({
    required NotificationService notificationService,
    required StorageService storageService,
    required AnalyticsService analyticsService,
  })  : _notificationService = notificationService,
        _storageService = storageService,
        _analyticsService = analyticsService {
    _initializeService();
  }

  void _initializeService() {
    _loadNotificationPreferences();
    _startBatchProcessing();
  }

  /// Send notification for a new friend request
  Future<Either<String, bool>> sendFriendRequestNotification({
    required FriendRequestModel request,
  }) async {
    try {
      // Check preferences
      if (!_shouldSendNotification('friend_requests')) {
        return Right(false);
      }

      // Check rate limiting
      if (!_isWithinRateLimit('friend_request_${request.senderId}')) {
        return Right(false);
      }

      final notification = _PendingNotification(
        id: 'friend_request_${request.id}',
        type: 'friend_request',
        title: 'New friend request',
        body: '${request.senderName} sent you a friend request',
        data: {
          'type': 'friend_request',
          'request_id': request.id,
          'sender_id': request.senderId,
        },
        priority: NotificationPriority.normal,
        timestamp: DateTime.now(),
      );

      await _queueNotification('friend_requests', notification);

      return Right(true);
    } catch (e) {
      debugPrint('Error sending friend request notification: $e');
      return Left('Failed to send notification: ${e.toString()}');
    }
  }

  /// Send notification for accepted friend request
  Future<Either<String, bool>> sendFriendRequestAcceptedNotification({
    required FriendRequestModel request,
  }) async {
    try {
      if (!_shouldSendNotification('friend_requests')) {
        return Right(false);
      }

      if (!_isWithinRateLimit('friend_accepted_${request.targetUserId}')) {
        return Right(false);
      }

      final notification = _PendingNotification(
        id: 'friend_accepted_${request.id}',
        type: 'friend_request_accepted',
        title: 'Friend request accepted',
        body: '${request.targetUserName} accepted your friend request',
        data: {
          'type': 'friend_request_accepted',
          'request_id': request.id,
          'user_id': request.targetUserId,
        },
        priority: NotificationPriority.normal,
        timestamp: DateTime.now(),
      );

      await _queueNotification('friend_requests', notification);

      return Right(true);
    } catch (e) {
      debugPrint('Error sending friend request accepted notification: $e');
      return Left('Failed to send notification: ${e.toString()}');
    }
  }

  /// Send notification for post reaction
  Future<Either<String, bool>> sendReactionNotification({
    required PostModel post,
    required ReactionModel reaction,
  }) async {
    try {
      if (!_shouldSendNotification('reactions')) {
        return Right(false);
      }

      if (!_isWithinRateLimit('reaction_${post.id}')) {
        return Right(false);
      }

      final reactionText = _getReactionText(reaction.type);
      
      final notification = _PendingNotification(
        id: 'reaction_${reaction.id}',
        type: 'post_reaction',
        title: 'Someone $reactionText your post',
        body: _truncateText(post.content, 50),
        data: {
          'type': 'post_reaction',
          'post_id': post.id,
          'reaction_id': reaction.id,
          'user_id': reaction.userId,
        },
        priority: NotificationPriority.low,
        timestamp: DateTime.now(),
      );

      // Batch reactions to avoid spam
      await _queueNotification('reactions_${post.id}', notification);

      return Right(true);
    } catch (e) {
      debugPrint('Error sending reaction notification: $e');
      return Left('Failed to send notification: ${e.toString()}');
    }
  }

  /// Send notification for post comment
  Future<Either<String, bool>> sendCommentNotification({
    required PostModel post,
    required CommentModel comment,
  }) async {
    try {
      if (!_shouldSendNotification('comments')) {
        return Right(false);
      }

      if (!_isWithinRateLimit('comment_${post.id}')) {
        return Right(false);
      }

      final notification = _PendingNotification(
        id: 'comment_${comment.id}',
        type: 'post_comment',
        title: 'New comment on your post',
        body: '${comment.authorName}: ${_truncateText(comment.content, 50)}',
        data: {
          'type': 'post_comment',
          'post_id': post.id,
          'comment_id': comment.id,
          'user_id': comment.authorId,
        },
        priority: NotificationPriority.normal,
        timestamp: DateTime.now(),
      );

      await _queueNotification('comments_${post.id}', notification);

      return Right(true);
    } catch (e) {
      debugPrint('Error sending comment notification: $e');
      return Left('Failed to send notification: ${e.toString()}');
    }
  }

  /// Send notification for mention in post or comment
  Future<Either<String, bool>> sendMentionNotifications({
    required PostModel post,
    required List<String> mentionedUserIds,
    CommentModel? comment,
  }) async {
    try {
      if (!_shouldSendNotification('mentions')) {
        return Right(false);
      }

      final results = <Either<String, bool>>[];

      for (final userId in mentionedUserIds) {
        if (!_isWithinRateLimit('mention_$userId')) {
          continue;
        }

        final isInComment = comment != null;
        final contentText = isInComment ? comment.content : post.content;

        final notification = _PendingNotification(
          id: 'mention_${userId}_${post.id}_${comment?.id ?? 'post'}',
          type: 'mention',
          title: isInComment ? 'You were mentioned in a comment' : 'You were mentioned in a post',
          body: '${isInComment ? comment.authorName : post.authorName}: ${_truncateText(contentText, 50)}',
          data: {
            'type': 'mention',
            'post_id': post.id,
            'comment_id': comment?.id,
            'mentioned_by': isInComment ? comment.authorId : post.authorId,
            'user_id': userId,
          },
          priority: NotificationPriority.high,
          timestamp: DateTime.now(),
        );

        final result = await _queueNotification('mentions', notification);
        results.add(result);
      }

      // Return success if at least one notification was queued
      final hasSuccess = results.any((r) => r.isRight && (r.rightOrNull() ?? false));
      return Right(hasSuccess);
    } catch (e) {
      debugPrint('Error sending mention notifications: $e');
      return Left('Failed to send notifications: ${e.toString()}');
    }
  }

  /// Send notification for new message
  Future<Either<String, bool>> sendMessageNotification({
    required MessageModel message,
    String? senderName,
  }) async {
    try {
      if (!_shouldSendNotification('messages')) {
        return Right(false);
      }

      if (!_isWithinRateLimit('message_${message.conversationId}')) {
        return Right(false);
      }

      final displayName = senderName ?? 'Someone';
      final body = _getMessageNotificationBody(message);

      final notification = _PendingNotification(
        id: 'message_${message.id}',
        type: 'chat_message',
        title: displayName,
        body: body,
        data: {
          'type': 'chat_message',
          'conversation_id': message.conversationId,
          'message_id': message.id,
          'sender_id': message.senderId,
        },
        priority: NotificationPriority.high,
        timestamp: DateTime.now(),
      );

      // Group messages by conversation for batching
      await _queueNotification('messages_${message.conversationId}', notification);

      return Right(true);
    } catch (e) {
      debugPrint('Error sending message notification: $e');
      return Left('Failed to send notification: ${e.toString()}');
    }
  }

  /// Update notification preferences
  Future<Either<String, bool>> updateNotificationPreferences({
    required Map<String, dynamic> preferences,
  }) async {
    try {
      _notificationPreferences = preferences;
      await _storageService.saveNotificationPreferences(preferences);

      // Update Do Not Disturb settings
      _isDndEnabled = preferences['dnd_enabled'] ?? false;
      
      if (preferences['dnd_start_time'] != null) {
        _dndStartTime = TimeOfDay.fromDateTime(
          DateTime.parse(preferences['dnd_start_time']),
        );
      }
      
      if (preferences['dnd_end_time'] != null) {
        _dndEndTime = TimeOfDay.fromDateTime(
          DateTime.parse(preferences['dnd_end_time']),
        );
      }

      _dndDays = Set<String>.from(preferences['dnd_days'] ?? []);

      _analyticsService.trackEvent('notification_preferences_updated', {
        'dnd_enabled': _isDndEnabled,
        'enabled_types': preferences.keys
            .where((key) => preferences[key] == true)
            .toList(),
      });

      return Right(true);
    } catch (e) {
      debugPrint('Error updating notification preferences: $e');
      return Left('Failed to update preferences: ${e.toString()}');
    }
  }

  /// Get current notification preferences
  Map<String, dynamic> getNotificationPreferences() {
    return Map<String, dynamic>.from(_notificationPreferences);
  }

  /// Clear all pending notifications
  Future<Either<String, bool>> clearAllNotifications() async {
    try {
      _notificationService.clearAllNotifications();
      
      _pendingNotifications.clear();
      
      _analyticsService.trackEvent('all_notifications_cleared');
      
      return Right(true);
    } catch (e) {
      debugPrint('Error clearing notifications: $e');
      return Left('Failed to clear notifications: ${e.toString()}');
    }
  }

  /// Clear notifications for specific type
  Future<Either<String, bool>> clearNotificationsByType(String type) async {
    try {
      await _notificationService.clearNotificationsByGroup(type);
      
      _pendingNotifications.removeWhere((key, _) => key.startsWith(type));
      
      _analyticsService.trackEvent('notifications_cleared_by_type', {
        'type': type,
      });
      
      return Right(true);
    } catch (e) {
      debugPrint('Error clearing notifications by type: $e');
      return Left('Failed to clear notifications: ${e.toString()}');
    }
  }

  /// Handle deep link from notification
  Future<Either<String, Map<String, dynamic>>> handleNotificationDeepLink({
    required Map<String, dynamic> notificationData,
  }) async {
    try {
      final type = notificationData['type'] as String?;
      
      if (type == null) {
        return Left('Invalid notification data');
      }

      // Track deep link analytics
      _analyticsService.trackEvent('notification_deep_link_opened', {
        'type': type,
      });

      // Return navigation data based on type
      switch (type) {
        case 'friend_request':
          return Right({
            'route': '/friends/requests',
            'params': {
              'request_id': notificationData['request_id'],
            },
          });
          
        case 'chat_message':
          return Right({
            'route': '/chat',
            'params': {
              'conversation_id': notificationData['conversation_id'],
              'message_id': notificationData['message_id'],
            },
          });
          
        case 'post_reaction':
        case 'post_comment':
          return Right({
            'route': '/post',
            'params': {
              'post_id': notificationData['post_id'],
            },
          });
          
        case 'mention':
          return Right({
            'route': notificationData['comment_id'] != null 
                ? '/post' 
                : '/post',
            'params': {
              'post_id': notificationData['post_id'],
              'comment_id': notificationData['comment_id'],
            },
          });
          
        default:
          return Left('Unknown notification type: $type');
      }
    } catch (e) {
      debugPrint('Error handling notification deep link: $e');
      return Left('Failed to handle deep link: ${e.toString()}');
    }
  }

  Future<Either<String, bool>> _queueNotification(
    String batchKey,
    _PendingNotification notification,
  ) async {
    try {
      // Check if notifications are enabled and within Do Not Disturb hours
      if (!_shouldShowNotification()) {
        return Right(false);
      }

      _pendingNotifications[batchKey] ??= [];
      _pendingNotifications[batchKey]!.add(notification);

      // Update rate limiting
      _lastNotificationTime[notification.id] = DateTime.now();

      return Right(true);
    } catch (e) {
      return Left('Failed to queue notification: ${e.toString()}');
    }
  }

  void _startBatchProcessing() {
    _batchProcessingTimer = Timer.periodic(_batchDelay, (_) {
      _processPendingNotifications();
    });
  }

  Future<void> _processPendingNotifications() async {
    if (_pendingNotifications.isEmpty) return;

    try {
      final batches = Map<String, List<_PendingNotification>>.from(_pendingNotifications);
      _pendingNotifications.clear();

      for (final entry in batches.entries) {
        final batchKey = entry.key;
        final notifications = entry.value;

        if (notifications.isEmpty) continue;

        // Sort by priority and timestamp
        notifications.sort((a, b) {
          final priorityCompare = b.priority.index.compareTo(a.priority.index);
          if (priorityCompare != 0) return priorityCompare;
          return b.timestamp.compareTo(a.timestamp);
        });

        if (notifications.length == 1) {
          // Send single notification
          final notification = notifications.first;
          await _sendNotification(notification);
        } else {
          // Send batched notification
          await _sendBatchedNotification(batchKey, notifications);
        }

        // Update analytics
        for (final notification in notifications) {
          _notificationCounts[notification.type] = 
              (_notificationCounts[notification.type] ?? 0) + 1;
        }
      }

      _analyticsService.trackEvent('notifications_batch_processed', {
        'batches_count': batches.length,
        'notifications_count': batches.values.expand((x) => x).length,
      });
    } catch (e) {
      debugPrint('Error processing pending notifications: $e');
    }
  }

  Future<void> _sendNotification(_PendingNotification notification) async {
    try {
      await _notificationService.showNotification(
        id: notification.id.hashCode,
        title: notification.title,
        body: notification.body,
        data: notification.data,
        priority: _convertPriority(notification.priority),
      );
    } catch (e) {
      debugPrint('Error sending notification: $e');
    }
  }

  Future<void> _sendBatchedNotification(
    String batchKey,
    List<_PendingNotification> notifications,
  ) async {
    try {
      final count = notifications.length;
      final type = _getBatchType(batchKey);
      
      String title;
      String body;

      switch (type) {
        case 'reactions':
          title = '$count new reactions';
          body = 'People reacted to your post';
          break;
        case 'comments':
          title = '$count new comments';
          body = 'People commented on your post';
          break;
        case 'messages':
          title = '$count new messages';
          body = 'You have new messages';
          break;
        case 'friend_requests':
          title = '$count friend requests';
          body = 'You have new friend requests';
          break;
        default:
          title = '$count new notifications';
          body = 'You have new activity';
      }

      await _notificationService.showNotification(
        id: batchKey.hashCode,
        title: title,
        body: body,
        data: {
          'type': 'batched',
          'batch_type': type,
          'count': count,
        },
        priority: _convertPriority(notifications.first.priority),
      );
    } catch (e) {
      debugPrint('Error sending batched notification: $e');
    }
  }

  bool _shouldSendNotification(String type) {
    return _notificationPreferences[type] ?? true;
  }

  bool _shouldShowNotification() {
    if (!_isDndEnabled) return true;

    final now = DateTime.now();
    final currentTime = TimeOfDay.fromDateTime(now);
    final currentDay = _getDayOfWeek(now.weekday);

    // Check if current day is in DND days
    if (_dndDays.contains(currentDay)) {
      // Check if current time is within DND hours
      if (_dndStartTime != null && _dndEndTime != null) {
        return !_isTimeInRange(currentTime, _dndStartTime!, _dndEndTime!);
      }
    }

    return true;
  }

  bool _isWithinRateLimit(String key) {
    final lastTime = _lastNotificationTime[key];
    if (lastTime == null) return true;
    
    return DateTime.now().difference(lastTime).compareTo(_rateLimit) > 0;
  }

  bool _isTimeInRange(TimeOfDay current, TimeOfDay start, TimeOfDay end) {
    final currentMinutes = current.hour * 60 + current.minute;
    final startMinutes = start.hour * 60 + start.minute;
    final endMinutes = end.hour * 60 + end.minute;

    if (startMinutes <= endMinutes) {
      return currentMinutes >= startMinutes && currentMinutes <= endMinutes;
    } else {
      // Crosses midnight
      return currentMinutes >= startMinutes || currentMinutes <= endMinutes;
    }
  }

  String _getDayOfWeek(int weekday) {
    const days = [
      'monday', 'tuesday', 'wednesday', 'thursday',
      'friday', 'saturday', 'sunday'
    ];
    return days[weekday - 1];
  }

  String _getBatchType(String batchKey) {
    if (batchKey.startsWith('reactions')) return 'reactions';
    if (batchKey.startsWith('comments')) return 'comments';
    if (batchKey.startsWith('messages')) return 'messages';
    if (batchKey.startsWith('friend_requests')) return 'friend_requests';
    return 'general';
  }

  String _getReactionText(String reactionType) {
    switch (reactionType) {
      case 'like':
        return 'liked';
      case 'love':
        return 'loved';
      case 'haha':
        return 'laughed at';
      case 'wow':
        return 'was amazed by';
      case 'sad':
        return 'was saddened by';
      case 'angry':
        return 'was angered by';
      default:
        return 'reacted to';
    }
  }

  String _getMessageNotificationBody(MessageModel message) {
    switch (message.type) {
      case 'image':
        return 'Sent a photo';
      case 'video':
        return 'Sent a video';
      case 'audio':
        return 'Sent a voice message';
      case 'file':
        return 'Sent a file';
      case 'location':
        return 'Sent location';
      default:
        return _truncateText(message.content, 50);
    }
  }

  String _truncateText(String text, int maxLength) {
    if (text.length <= maxLength) return text;
    return '${text.substring(0, maxLength)}...';
  }

  NotificationPriority _convertPriority(NotificationPriority priority) {
    return priority;
  }

  Future<void> _loadNotificationPreferences() async {
    try {
      _notificationPreferences = await _storageService.getNotificationPreferences();
      
      // Load DND settings
      _isDndEnabled = _notificationPreferences['dnd_enabled'] ?? false;
      
      if (_notificationPreferences['dnd_start_time'] != null) {
        _dndStartTime = TimeOfDay.fromDateTime(
          DateTime.parse(_notificationPreferences['dnd_start_time']),
        );
      }
      
      if (_notificationPreferences['dnd_end_time'] != null) {
        _dndEndTime = TimeOfDay.fromDateTime(
          DateTime.parse(_notificationPreferences['dnd_end_time']),
        );
      }

      _dndDays = Set<String>.from(_notificationPreferences['dnd_days'] ?? []);
      
      debugPrint('Notification preferences loaded');
    } catch (e) {
      debugPrint('Error loading notification preferences: $e');
      
      // Set default preferences
      _notificationPreferences = {
        'friend_requests': true,
        'messages': true,
        'comments': true,
        'reactions': true,
        'mentions': true,
        'dnd_enabled': false,
      };
    }
  }

  /// Get notification statistics
  Map<String, dynamic> getNotificationStats() {
    return {
      'pending_batches': _pendingNotifications.length,
      'notification_counts': Map<String, int>.from(_notificationCounts),
      'dnd_enabled': _isDndEnabled,
      'rate_limited_keys': _lastNotificationTime.length,
    };
  }

  /// Dispose service and cleanup
  void dispose() {
    _batchProcessingTimer?.cancel();
    _pendingNotifications.clear();
    _lastNotificationTime.clear();
    _notificationCounts.clear();
  }
}

class _PendingNotification {
  final String id;
  final String type;
  final String title;
  final String body;
  final Map<String, dynamic> data;
  final NotificationPriority priority;
  final DateTime timestamp;

  _PendingNotification({
    required this.id,
    required this.type,
    required this.title,
    required this.body,
    required this.data,
    required this.priority,
    required this.timestamp,
  });
}

enum NotificationPriority {
  low,
  normal,
  high,
}

class TimeOfDay {
  final int hour;
  final int minute;

  TimeOfDay({required this.hour, required this.minute});

  factory TimeOfDay.fromDateTime(DateTime dateTime) {
    return TimeOfDay(hour: dateTime.hour, minute: dateTime.minute);
  }
}
