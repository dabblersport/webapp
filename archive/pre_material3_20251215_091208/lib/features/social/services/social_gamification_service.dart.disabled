import 'dart:async';
import 'package:dabbler/core/utils/either.dart';
import 'social_analytics_service.dart';
import 'social_insights_service.dart';

/// Service for managing social gamification features including achievements, badges, and challenges
class SocialGamificationService {
  final SocialAnalyticsService _analyticsService;
  final SocialInsightsService _insightsService;
  
  // User progress tracking
  final Map<String, UserGamificationProfile> _userProfiles = {};
  final Map<String, List<Achievement>> _userAchievements = {};
  final Map<String, List<Badge>> _userBadges = {};
  final Map<String, List<Challenge>> _activeChallenges = {};
  
  // Achievement and badge definitions
  final Map<String, AchievementDefinition> _achievementDefinitions = {};
  final Map<String, BadgeDefinition> _badgeDefinitions = {};
  final Map<String, ChallengeTemplate> _challengeTemplates = {};
  
  // Leaderboards
  final Map<LeaderboardType, Leaderboard> _leaderboards = {};
  
  // Event tracking
  Timer? _gamificationTimer;
  static const Duration _checkInterval = Duration(minutes: 5);

  SocialGamificationService({
    required SocialAnalyticsService analyticsService,
    required SocialInsightsService insightsService,
  }) : _analyticsService = analyticsService,
       _insightsService = insightsService {
    _initializeGamificationSystem();
  }

  /// Initialize the gamification system
  void _initializeGamificationSystem() {
    _loadAchievementDefinitions();
    _loadBadgeDefinitions();
    _loadChallengeTemplates();
    _initializeLeaderboards();
    _startPeriodicChecks();
  }

  /// Get user's gamification profile
  Future<Either<String, UserGamificationProfile>> getUserProfile(String userId) async {
    try {
      // Get or create user profile
      var profile = _userProfiles[userId];
      if (profile == null) {
        profile = await _createUserProfile(userId);
        _userProfiles[userId] = profile;
      }
      
      // Update profile with latest data
      profile = await _updateUserProfile(userId, profile);
      _userProfiles[userId] = profile;

      return Right(profile);
    } catch (e) {
      return Left('Failed to get user profile: $e');
    }
  }

  /// Track user action for gamification
  Future<Either<String, GamificationResult>> trackUserAction(
    String userId,
    GamificationAction action, {
    Map<String, dynamic> metadata = const {},
  }) async {
    try {
      final results = <GamificationEvent>[];
      
      // Check for new achievements
      final achievements = await _checkAchievements(userId, action, metadata);
      results.addAll(achievements);
      
      // Check for new badges
      final badges = await _checkBadges(userId, action, metadata);
      results.addAll(badges);
      
      // Update challenge progress
      final challengeUpdates = await _updateChallengeProgress(userId, action, metadata);
      results.addAll(challengeUpdates);
      
      // Update user profile
      await _updateUserProfileFromAction(userId, action, metadata);
      
      // Update leaderboards
      await _updateLeaderboards(userId, action, metadata);
      
      // Calculate rewards
      final rewards = await _calculateRewards(userId, results);

      final result = GamificationResult(
        userId: userId,
        action: action,
        events: results,
        rewards: rewards,
        newLevel: await _checkLevelUp(userId),
        streakUpdates: await _updateStreaks(userId, action),
        processedAt: DateTime.now(),
      );

      return Right(result);
    } catch (e) {
      return Left('Failed to track user action: $e');
    }
  }

  /// Get user achievements
  Future<Either<String, List<Achievement>>> getUserAchievements(
    String userId, {
    AchievementCategory? category,
    bool unlockedOnly = false,
  }) async {
    try {
      var achievements = _userAchievements[userId] ?? [];
      
      // Filter by category
      if (category != null) {
        achievements = achievements.where((a) => a.category == category).toList();
      }
      
      // Filter by unlocked status
      if (unlockedOnly) {
        achievements = achievements.where((a) => a.unlockedAt != null).toList();
      }
      
      // Sort by unlock date (most recent first)
      achievements.sort((a, b) {
        if (a.unlockedAt == null && b.unlockedAt == null) return 0;
        if (a.unlockedAt == null) return 1;
        if (b.unlockedAt == null) return -1;
        return b.unlockedAt!.compareTo(a.unlockedAt!);
      });

      return Right(achievements);
    } catch (e) {
      return Left('Failed to get user achievements: $e');
    }
  }

  /// Get user badges
  Future<Either<String, List<Badge>>> getUserBadges(
    String userId, {
    BadgeCategory? category,
    bool earnedOnly = false,
  }) async {
    try {
      var badges = _userBadges[userId] ?? [];
      
      // Filter by category
      if (category != null) {
        badges = badges.where((b) => b.category == category).toList();
      }
      
      // Filter by earned status
      if (earnedOnly) {
        badges = badges.where((b) => b.earnedAt != null).toList();
      }

      return Right(badges);
    } catch (e) {
      return Left('Failed to get user badges: $e');
    }
  }

  /// Get active challenges for user
  Future<Either<String, List<Challenge>>> getUserChallenges(
    String userId, {
    ChallengeStatus? status,
    ChallengeCategory? category,
  }) async {
    try {
      var challenges = _activeChallenges[userId] ?? [];
      
      // Filter by status
      if (status != null) {
        challenges = challenges.where((c) => c.status == status).toList();
      }
      
      // Filter by category
      if (category != null) {
        challenges = challenges.where((c) => c.category == category).toList();
      }

      return Right(challenges);
    } catch (e) {
      return Left('Failed to get user challenges: $e');
    }
  }

  /// Start a new challenge for user
  Future<Either<String, Challenge>> startChallenge(
    String userId,
    String challengeTemplateId,
  ) async {
    try {
      final template = _challengeTemplates[challengeTemplateId];
      if (template == null) {
        return Left('Challenge template not found');
      }
      
      // Check if user already has this challenge active
      final activeChallenges = _activeChallenges[userId] ?? [];
      final existingChallenge = activeChallenges.where(
        (c) => c.templateId == challengeTemplateId && c.status == ChallengeStatus.active
      ).firstOrNull;
      
      if (existingChallenge != null) {
        return Left('Challenge already active');
      }
      
      // Create new challenge instance
      final challenge = Challenge(
        id: 'challenge_${userId}_${challengeTemplateId}_${DateTime.now().millisecondsSinceEpoch}',
        templateId: challengeTemplateId,
        userId: userId,
        title: template.title,
        description: template.description,
        category: template.category,
        difficulty: template.difficulty,
        duration: template.duration,
        targets: Map<String, dynamic>.from(template.targets),
        progress: {},
        rewards: List.from(template.rewards),
        status: ChallengeStatus.active,
        startedAt: DateTime.now(),
        expiresAt: DateTime.now().add(template.duration),
      );
      
      // Add to user's active challenges
      _activeChallenges.putIfAbsent(userId, () => []).add(challenge);

      return Right(challenge);
    } catch (e) {
      return Left('Failed to start challenge: $e');
    }
  }

  /// Get leaderboard
  Future<Either<String, Leaderboard>> getLeaderboard(
    LeaderboardType type, {
    Duration period = const Duration(days: 30),
    int limit = 100,
  }) async {
    try {
      var leaderboard = _leaderboards[type];
      if (leaderboard == null) {
        return Left('Leaderboard not found');
      }
      
      // Filter by period
      final cutoffDate = DateTime.now().subtract(period);
      final filteredEntries = leaderboard.entries
          .where((e) => e.lastUpdated.isAfter(cutoffDate))
          .take(limit)
          .toList();
      
      // Sort by score
      filteredEntries.sort((a, b) => b.score.compareTo(a.score));
      
      final filteredLeaderboard = Leaderboard(
        type: type,
        period: period,
        entries: filteredEntries,
        lastUpdated: DateTime.now(),
      );

      return Right(filteredLeaderboard);
    } catch (e) {
      return Left('Failed to get leaderboard: $e');
    }
  }

  /// Get user's leaderboard position
  Future<Either<String, LeaderboardPosition>> getUserLeaderboardPosition(
    String userId,
    LeaderboardType type,
  ) async {
    try {
      final leaderboard = _leaderboards[type];
      if (leaderboard == null) {
        return Left('Leaderboard not found');
      }
      
      final userEntry = leaderboard.entries
          .where((e) => e.userId == userId)
          .firstOrNull;
      
      if (userEntry == null) {
        return Left('User not found on leaderboard');
      }
      
      // Calculate position
      final position = leaderboard.entries
          .where((e) => e.score > userEntry.score)
          .length + 1;
      
      final leaderboardPosition = LeaderboardPosition(
        userId: userId,
        position: position,
        score: userEntry.score,
        percentile: _calculatePercentile(position, leaderboard.entries.length),
        totalParticipants: leaderboard.entries.length,
        type: type,
      );

      return Right(leaderboardPosition);
    } catch (e) {
      return Left('Failed to get user leaderboard position: $e');
    }
  }

  /// Generate personalized challenges
  Future<Either<String, List<ChallengeRecommendation>>> generatePersonalizedChallenges(
    String userId, {
    int maxRecommendations = 5,
  }) async {
    try {
      // Get user insights
      final insightsResult = await _insightsService.generateUserInsights(userId);
      if (insightsResult.isLeft) {
        return Left(insightsResult.leftOrNull()!);
      }
      
      final insights = insightsResult.rightOrNull()!;
      
      // Currently using simplified logic without insights analysis
      
      // Get user profile
      final profileResult = await getUserProfile(userId);
      if (profileResult.isLeft) {
        return Left(profileResult.leftOrNull()!);
      }
      
      // final profile = profileResult.rightOrNull()!;
      
      // Generate challenge recommendations based on insights and profile
      final recommendations = <ChallengeRecommendation>[];
      
      // Engagement-based challenges
      // if (insights.keyMetrics.engagementRate < 0.05) {
      //   recommendations.add(ChallengeRecommendation(
      //     templateId: 'engagement_boost',
      //     title: 'Engagement Booster',
      //     description: 'Increase your engagement rate by posting more interactive content',
      //     category: ChallengeCategory.engagement,
      //     difficulty: ChallengeDifficulty.medium,
      //     estimatedDuration: const Duration(days: 7),
      //     potentialReward: 500,
      //     personalizedReason: 'Your engagement rate could use improvement',
      //     confidence: 0.8,
      //   ));
      // }
      
      // Friendship challenges
      // if (insights.keyMetrics.friendsCount < 50) {
      //   recommendations.add(ChallengeRecommendation(
      //     templateId: 'network_builder',
      //     title: 'Network Builder',
      //     description: 'Connect with 10 new people this week',
      //     category: ChallengeCategory.networking,
      //     difficulty: ChallengeDifficulty.easy,
      //     estimatedDuration: const Duration(days: 7),
      //     potentialReward: 300,
      //     personalizedReason: 'Expanding your network could boost your social presence',
      //     confidence: 0.7,
      //   ));
      // }
      
      // Sort by potential impact and user preferences
      recommendations.sort((a, b) => b.confidence.compareTo(a.confidence));
      
      return Right(recommendations.take(maxRecommendations).toList());
    } catch (e) {
      return Left('Failed to generate personalized challenges: $e');
    }
  }

  /// Clean up expired challenges and update streaks
  Future<void> performMaintenanceTasks() async {
    final now = DateTime.now();
    
    // Clean up expired challenges
    for (final userId in _activeChallenges.keys) {
      final challenges = _activeChallenges[userId] ?? [];
      
      // Mark expired challenges as expired
      final expiredChallenges = challenges.where((c) => 
          c.status == ChallengeStatus.active && c.expiresAt.isBefore(now)
      );
      
      for (final challenge in expiredChallenges) {
        challenge.status = ChallengeStatus.expired;
        challenge.completedAt = now;
      }
      
      _activeChallenges[userId] = challenges;
    }
    
    // Update user streaks
    for (final userId in _userProfiles.keys) {
      await _updateDailyStreaks(userId);
    }
  }

  /// Dispose resources
  Future<void> dispose() async {
    _gamificationTimer?.cancel();
    _userProfiles.clear();
    _userAchievements.clear();
    _userBadges.clear();
    _activeChallenges.clear();
    _leaderboards.clear();
  }

  // Private helper methods
  void _loadAchievementDefinitions() {
    // Load achievement definitions - in real app would come from database/config
    _achievementDefinitions['first_post'] = AchievementDefinition(
      id: 'first_post',
      title: 'First Steps',
      description: 'Created your first post',
      category: AchievementCategory.milestone,
      rarity: AchievementRarity.common,
      points: 50,
      iconUrl: 'assets/achievements/first_post.png',
    );
    
    _achievementDefinitions['social_butterfly'] = AchievementDefinition(
      id: 'social_butterfly',
      title: 'Social Butterfly',
      description: 'Made 100 friends',
      category: AchievementCategory.social,
      rarity: AchievementRarity.rare,
      points: 500,
      iconUrl: 'assets/achievements/social_butterfly.png',
    );
    
    _achievementDefinitions['conversation_starter'] = AchievementDefinition(
      id: 'conversation_starter',
      title: 'Conversation Starter',
      description: 'Started 10 conversations',
      category: AchievementCategory.communication,
      rarity: AchievementRarity.uncommon,
      points: 200,
      iconUrl: 'assets/achievements/conversation_starter.png',
    );
    
    // Add more achievement definitions...
  }

  void _loadBadgeDefinitions() {
    // Load badge definitions
    _badgeDefinitions['engagement_expert'] = BadgeDefinition(
      id: 'engagement_expert',
      title: 'Engagement Expert',
      description: 'Maintain high engagement for 30 days',
      category: BadgeCategory.engagement,
      tier: BadgeTier.gold,
      requirements: {'engagement_rate': 0.1, 'days': 30},
      iconUrl: 'assets/badges/engagement_expert.png',
    );
    
    // Add more badge definitions...
  }

  void _loadChallengeTemplates() {
    // Load challenge templates
    _challengeTemplates['engagement_boost'] = ChallengeTemplate(
      id: 'engagement_boost',
      title: 'Engagement Booster',
      description: 'Get 100 total engagements this week',
      category: ChallengeCategory.engagement,
      difficulty: ChallengeDifficulty.medium,
      duration: const Duration(days: 7),
      targets: {'total_engagements': 100},
      rewards: [
        ChallengeReward(type: 'points', value: 300),
        ChallengeReward(type: 'badge', value: 'engagement_booster'),
      ],
    );
    
    // Add more challenge templates...
  }

  void _initializeLeaderboards() {
    // Initialize empty leaderboards
    for (final type in LeaderboardType.values) {
      _leaderboards[type] = Leaderboard(
        type: type,
        period: const Duration(days: 30),
        entries: [],
        lastUpdated: DateTime.now(),
      );
    }
  }

  void _startPeriodicChecks() {
    _gamificationTimer = Timer.periodic(_checkInterval, (_) => _performPeriodicTasks());
  }

  Future<void> _performPeriodicTasks() async {
    // Perform maintenance tasks periodically
    await performMaintenanceTasks();
    
    // Update achievements and badges that depend on time-based criteria
    for (final userId in _userProfiles.keys) {
      await _checkTimeBasedAchievements(userId);
      await _checkTimeBasedBadges(userId);
    }
  }

  Future<UserGamificationProfile> _createUserProfile(String userId) async {
    final profile = UserGamificationProfile(
      userId: userId,
      level: 1,
      totalPoints: 0,
      streaks: {},
      statistics: {},
      preferences: GamificationPreferences(),
      createdAt: DateTime.now(),
      lastActiveAt: DateTime.now(),
    );
    
    // Initialize user achievements and badges
    _userAchievements[userId] = [];
    _userBadges[userId] = [];
    _activeChallenges[userId] = [];
    
    return profile;
  }

  Future<UserGamificationProfile> _updateUserProfile(String userId, UserGamificationProfile profile) async {
    // Update profile with latest analytics data
    final analyticsResult = await _analyticsService.calculateUserEngagement(userId);
    if (analyticsResult.isRight) {
      final analytics = analyticsResult.rightOrNull()!;
      
      // Update statistics  
      profile.statistics['posts_created'] = analytics.postMetrics.totalPosts;
      profile.statistics['total_likes'] = analytics.postMetrics.totalLikes;
      profile.statistics['total_comments'] = analytics.postMetrics.totalComments;
      profile.statistics['total_shares'] = analytics.postMetrics.totalShares;
    }
    
    profile.lastActiveAt = DateTime.now();
    return profile;
  }

  Future<List<GamificationEvent>> _checkAchievements(
    String userId, 
    GamificationAction action, 
    Map<String, dynamic> metadata,
  ) async {
    final events = <GamificationEvent>[];
    final userAchievements = _userAchievements[userId] ?? [];
    
    // Check each achievement definition
    for (final definition in _achievementDefinitions.values) {
      // Skip if user already has this achievement
      if (userAchievements.any((a) => a.definitionId == definition.id && a.unlockedAt != null)) {
        continue;
      }
      
      // Check if action triggers this achievement
      final isUnlocked = await _checkAchievementCondition(userId, definition, action, metadata);
      
      if (isUnlocked) {
        final achievement = Achievement(
          id: 'achievement_${userId}_${definition.id}_${DateTime.now().millisecondsSinceEpoch}',
          definitionId: definition.id,
          userId: userId,
          title: definition.title,
          description: definition.description,
          category: definition.category,
          rarity: definition.rarity,
          points: definition.points,
          iconUrl: definition.iconUrl,
          unlockedAt: DateTime.now(),
          progress: 1.0,
        );
        
        userAchievements.add(achievement);
        _userAchievements[userId] = userAchievements;
        
        events.add(GamificationEvent(
          type: GamificationEventType.achievementUnlocked,
          userId: userId,
          data: {'achievement': achievement},
          timestamp: DateTime.now(),
        ));
      }
    }
    
    return events;
  }

  Future<List<GamificationEvent>> _checkBadges(
    String userId, 
    GamificationAction action, 
    Map<String, dynamic> metadata,
  ) async {
    final events = <GamificationEvent>[];
    // Similar implementation to achievements but for badges
    return events;
  }

  Future<List<GamificationEvent>> _updateChallengeProgress(
    String userId, 
    GamificationAction action, 
    Map<String, dynamic> metadata,
  ) async {
    final events = <GamificationEvent>[];
    final challenges = _activeChallenges[userId] ?? [];
    
    for (final challenge in challenges.where((c) => c.status == ChallengeStatus.active)) {
      final progressUpdated = _updateChallengeProgressForAction(challenge, action, metadata);
      
      if (progressUpdated) {
        events.add(GamificationEvent(
          type: GamificationEventType.challengeProgress,
          userId: userId,
          data: {'challenge': challenge},
          timestamp: DateTime.now(),
        ));
        
        // Check if challenge is completed
        if (_isChallengeCompleted(challenge)) {
          challenge.status = ChallengeStatus.completed;
          challenge.completedAt = DateTime.now();
          
          events.add(GamificationEvent(
            type: GamificationEventType.challengeCompleted,
            userId: userId,
            data: {'challenge': challenge},
            timestamp: DateTime.now(),
          ));
        }
      }
    }
    
    return events;
  }

  Future<void> _updateUserProfileFromAction(
    String userId, 
    GamificationAction action, 
    Map<String, dynamic> metadata,
  ) async {
    final profile = _userProfiles[userId];
    if (profile == null) return;
    
    // Update statistics based on action
    switch (action) {
      case GamificationAction.postCreated:
        profile.statistics['posts_created'] = (profile.statistics['posts_created'] ?? 0) + 1;
        break;
      case GamificationAction.postLiked:
        profile.statistics['likes_given'] = (profile.statistics['likes_given'] ?? 0) + 1;
        break;
      case GamificationAction.postShared:
        profile.statistics['posts_shared'] = (profile.statistics['posts_shared'] ?? 0) + 1;
        break;
      case GamificationAction.commentAdded:
        profile.statistics['comments_made'] = (profile.statistics['comments_made'] ?? 0) + 1;
        break;
      case GamificationAction.friendAdded:
        profile.statistics['friends_added'] = (profile.statistics['friends_added'] ?? 0) + 1;
        break;
      case GamificationAction.messagesSent:
        final count = metadata['count'] as int? ?? 1;
        profile.statistics['messages_sent'] = (profile.statistics['messages_sent'] ?? 0) + count;
        break;
      case GamificationAction.profileUpdated:
        profile.statistics['profile_updates'] = (profile.statistics['profile_updates'] ?? 0) + 1;
        break;
      case GamificationAction.dailyLogin:
        profile.statistics['daily_logins'] = (profile.statistics['daily_logins'] ?? 0) + 1;
        break;
    }
    
    profile.lastActiveAt = DateTime.now();
  }

  Future<void> _updateLeaderboards(
    String userId, 
    GamificationAction action, 
    Map<String, dynamic> metadata,
  ) async {
    // Update relevant leaderboards based on action
    switch (action) {
      case GamificationAction.postCreated:
        await _updateLeaderboardEntry(userId, LeaderboardType.topPosters, 1);
        break;
      case GamificationAction.postLiked:
        await _updateLeaderboardEntry(userId, LeaderboardType.topEngagers, 1);
        break;
      case GamificationAction.friendAdded:
        await _updateLeaderboardEntry(userId, LeaderboardType.topNetworkers, 1);
        break;
      default:
        break;
    }
  }

  Future<void> _updateLeaderboardEntry(String userId, LeaderboardType type, int scoreIncrease) async {
    final leaderboard = _leaderboards[type];
    if (leaderboard == null) return;
    
    var entry = leaderboard.entries.where((e) => e.userId == userId).firstOrNull;
    
    if (entry == null) {
      entry = LeaderboardEntry(
        userId: userId,
        score: scoreIncrease,
        lastUpdated: DateTime.now(),
      );
      leaderboard.entries.add(entry);
    } else {
      entry.score += scoreIncrease;
      entry.lastUpdated = DateTime.now();
    }
    
    // Keep leaderboard sorted
    leaderboard.entries.sort((a, b) => b.score.compareTo(a.score));
    leaderboard.lastUpdated = DateTime.now();
  }

  Future<List<GamificationReward>> _calculateRewards(String userId, List<GamificationEvent> events) async {
    final rewards = <GamificationReward>[];
    
    for (final event in events) {
      switch (event.type) {
        case GamificationEventType.achievementUnlocked:
          final achievement = event.data['achievement'] as Achievement;
          rewards.add(GamificationReward(
            type: RewardType.points,
            value: achievement.points,
            description: 'Achievement: ${achievement.title}',
          ));
          break;
        case GamificationEventType.challengeCompleted:
          final challenge = event.data['challenge'] as Challenge;
          for (final reward in challenge.rewards) {
            rewards.add(GamificationReward(
              type: RewardType.values.firstWhere((t) => t.toString().split('.').last == reward.type),
              value: reward.value,
              description: 'Challenge: ${challenge.title}',
            ));
          }
          break;
        default:
          break;
      }
    }
    
    return rewards;
  }

  Future<LevelUpResult?> _checkLevelUp(String userId) async {
    final profile = _userProfiles[userId];
    if (profile == null) return null;
    
    final totalPoints = profile.totalPoints;
    final currentLevel = profile.level;
    final newLevel = _calculateLevelFromPoints(totalPoints);
    
    if (newLevel > currentLevel) {
      profile.level = newLevel;
      
      return LevelUpResult(
        userId: userId,
        previousLevel: currentLevel,
        newLevel: newLevel,
        pointsRequired: _pointsRequiredForLevel(newLevel),
        rewards: await _getLevelUpRewards(newLevel),
      );
    }
    
    return null;
  }

  Future<Map<StreakType, StreakUpdate>> _updateStreaks(String userId, GamificationAction action) async {
    final profile = _userProfiles[userId];
    if (profile == null) return {};
    
    final updates = <StreakType, StreakUpdate>{};
    
    // Update daily activity streak
    final today = DateTime.now().toUtc().copyWith(hour: 0, minute: 0, second: 0, microsecond: 0);
    final dailyStreak = profile.streaks[StreakType.dailyActivity] ?? 0;
    final lastActivity = profile.lastActiveAt.toUtc().copyWith(hour: 0, minute: 0, second: 0, microsecond: 0);
    
    if (lastActivity.isBefore(today)) {
      if (today.difference(lastActivity).inDays == 1) {
        // Consecutive day
        profile.streaks[StreakType.dailyActivity] = dailyStreak + 1;
        updates[StreakType.dailyActivity] = StreakUpdate(
          type: StreakType.dailyActivity,
          newValue: dailyStreak + 1,
          previousValue: dailyStreak,
          maintained: true,
        );
      } else {
        // Streak broken
        profile.streaks[StreakType.dailyActivity] = 1;
        updates[StreakType.dailyActivity] = StreakUpdate(
          type: StreakType.dailyActivity,
          newValue: 1,
          previousValue: dailyStreak,
          maintained: false,
        );
      }
    }
    
    return updates;
  }

  Future<bool> _checkAchievementCondition(
    String userId,
    AchievementDefinition definition,
    GamificationAction action,
    Map<String, dynamic> metadata,
  ) async {
    // Check specific achievement conditions
    switch (definition.id) {
      case 'first_post':
        return action == GamificationAction.postCreated;
      case 'social_butterfly':
        final profile = _userProfiles[userId];
        return (profile?.statistics['friends_added'] ?? 0) >= 100;
      case 'conversation_starter':
        final profile = _userProfiles[userId];
        return (profile?.statistics['conversations_started'] ?? 0) >= 10;
      default:
        return false;
    }
  }

  bool _updateChallengeProgressForAction(
    Challenge challenge,
    GamificationAction action,
    Map<String, dynamic> metadata,
  ) {
    bool updated = false;
    
    // Update challenge progress based on action type
    switch (action) {
      case GamificationAction.postCreated:
        if (challenge.targets.containsKey('posts_created')) {
          challenge.progress['posts_created'] = (challenge.progress['posts_created'] ?? 0) + 1;
          updated = true;
        }
        break;
      case GamificationAction.postLiked:
        if (challenge.targets.containsKey('total_engagements')) {
          challenge.progress['total_engagements'] = (challenge.progress['total_engagements'] ?? 0) + 1;
          updated = true;
        }
        break;
      // Add more action types...
      default:
        break;
    }
    
    return updated;
  }

  bool _isChallengeCompleted(Challenge challenge) {
    for (final target in challenge.targets.entries) {
      final progress = challenge.progress[target.key] ?? 0;
      if (progress < target.value) {
        return false;
      }
    }
    return true;
  }

  int _calculateLevelFromPoints(int points) {
    // Simple level calculation - could be more complex
    return (points / 1000).floor() + 1;
  }

  int _pointsRequiredForLevel(int level) {
    return level * 1000;
  }

  Future<List<LevelUpReward>> _getLevelUpRewards(int level) async {
    return [
      LevelUpReward(
        type: RewardType.points,
        value: level * 100,
        description: 'Level $level bonus points',
      ),
    ];
  }

  double _calculatePercentile(int position, int totalParticipants) {
    if (totalParticipants <= 1) return 100.0;
    return ((totalParticipants - position) / totalParticipants) * 100;
  }

  Future<void> _checkTimeBasedAchievements(String userId) async {
    // Check achievements that depend on time-based criteria
    // e.g., "Active for 30 days", "Posted every day for a week", etc.
  }

  Future<void> _checkTimeBasedBadges(String userId) async {
    // Check badges that depend on time-based criteria
    // e.g., "Consistent Poster", "Long-term Member", etc.
  }

  Future<void> _updateDailyStreaks(String userId) async {
    // Update daily streaks for users
    final profile = _userProfiles[userId];
    if (profile == null) return;
    
    final today = DateTime.now().toUtc().copyWith(hour: 0, minute: 0, second: 0, microsecond: 0);
    final lastActivity = profile.lastActiveAt.toUtc().copyWith(hour: 0, minute: 0, second: 0, microsecond: 0);
    
    // Reset streaks if user wasn't active yesterday
    if (today.difference(lastActivity).inDays > 1) {
      profile.streaks[StreakType.dailyActivity] = 0;
    }
  }
}

// Data classes for gamification
class UserGamificationProfile {
  final String userId;
  int level;
  int totalPoints;
  Map<StreakType, int> streaks;
  Map<String, int> statistics;
  GamificationPreferences preferences;
  final DateTime createdAt;
  DateTime lastActiveAt;

  UserGamificationProfile({
    required this.userId,
    required this.level,
    required this.totalPoints,
    required this.streaks,
    required this.statistics,
    required this.preferences,
    required this.createdAt,
    required this.lastActiveAt,
  });
}

class Achievement {
  final String id;
  final String definitionId;
  final String userId;
  final String title;
  final String description;
  final AchievementCategory category;
  final AchievementRarity rarity;
  final int points;
  final String iconUrl;
  final DateTime? unlockedAt;
  final double progress; // 0.0 to 1.0

  const Achievement({
    required this.id,
    required this.definitionId,
    required this.userId,
    required this.title,
    required this.description,
    required this.category,
    required this.rarity,
    required this.points,
    required this.iconUrl,
    this.unlockedAt,
    required this.progress,
  });
}

class Badge {
  final String id;
  final String definitionId;
  final String userId;
  final String title;
  final String description;
  final BadgeCategory category;
  final BadgeTier tier;
  final String iconUrl;
  final DateTime? earnedAt;
  final double progress;

  const Badge({
    required this.id,
    required this.definitionId,
    required this.userId,
    required this.title,
    required this.description,
    required this.category,
    required this.tier,
    required this.iconUrl,
    this.earnedAt,
    required this.progress,
  });
}

class Challenge {
  final String id;
  final String templateId;
  final String userId;
  final String title;
  final String description;
  final ChallengeCategory category;
  final ChallengeDifficulty difficulty;
  final Duration duration;
  final Map<String, dynamic> targets;
  final Map<String, dynamic> progress;
  final List<ChallengeReward> rewards;
  ChallengeStatus status;
  final DateTime startedAt;
  final DateTime expiresAt;
  DateTime? completedAt;

  Challenge({
    required this.id,
    required this.templateId,
    required this.userId,
    required this.title,
    required this.description,
    required this.category,
    required this.difficulty,
    required this.duration,
    required this.targets,
    required this.progress,
    required this.rewards,
    required this.status,
    required this.startedAt,
    required this.expiresAt,
    this.completedAt,
  });
}

class GamificationResult {
  final String userId;
  final GamificationAction action;
  final List<GamificationEvent> events;
  final List<GamificationReward> rewards;
  final LevelUpResult? newLevel;
  final Map<StreakType, StreakUpdate> streakUpdates;
  final DateTime processedAt;

  const GamificationResult({
    required this.userId,
    required this.action,
    required this.events,
    required this.rewards,
    this.newLevel,
    required this.streakUpdates,
    required this.processedAt,
  });
}

class Leaderboard {
  final LeaderboardType type;
  final Duration period;
  final List<LeaderboardEntry> entries;
  DateTime lastUpdated;

  Leaderboard({
    required this.type,
    required this.period,
    required this.entries,
    required this.lastUpdated,
  });
}

class LeaderboardEntry {
  final String userId;
  int score;
  DateTime lastUpdated;

  LeaderboardEntry({
    required this.userId,
    required this.score,
    required this.lastUpdated,
  });
}

class LeaderboardPosition {
  final String userId;
  final int position;
  final int score;
  final double percentile;
  final int totalParticipants;
  final LeaderboardType type;

  const LeaderboardPosition({
    required this.userId,
    required this.position,
    required this.score,
    required this.percentile,
    required this.totalParticipants,
    required this.type,
  });
}

class ChallengeRecommendation {
  final String templateId;
  final String title;
  final String description;
  final ChallengeCategory category;
  final ChallengeDifficulty difficulty;
  final Duration estimatedDuration;
  final int potentialReward;
  final String personalizedReason;
  final double confidence;

  const ChallengeRecommendation({
    required this.templateId,
    required this.title,
    required this.description,
    required this.category,
    required this.difficulty,
    required this.estimatedDuration,
    required this.potentialReward,
    required this.personalizedReason,
    required this.confidence,
  });
}

// Definition classes
class AchievementDefinition {
  final String id;
  final String title;
  final String description;
  final AchievementCategory category;
  final AchievementRarity rarity;
  final int points;
  final String iconUrl;

  const AchievementDefinition({
    required this.id,
    required this.title,
    required this.description,
    required this.category,
    required this.rarity,
    required this.points,
    required this.iconUrl,
  });
}

class BadgeDefinition {
  final String id;
  final String title;
  final String description;
  final BadgeCategory category;
  final BadgeTier tier;
  final Map<String, dynamic> requirements;
  final String iconUrl;

  const BadgeDefinition({
    required this.id,
    required this.title,
    required this.description,
    required this.category,
    required this.tier,
    required this.requirements,
    required this.iconUrl,
  });
}

class ChallengeTemplate {
  final String id;
  final String title;
  final String description;
  final ChallengeCategory category;
  final ChallengeDifficulty difficulty;
  final Duration duration;
  final Map<String, dynamic> targets;
  final List<ChallengeReward> rewards;

  const ChallengeTemplate({
    required this.id,
    required this.title,
    required this.description,
    required this.category,
    required this.difficulty,
    required this.duration,
    required this.targets,
    required this.rewards,
  });
}

// Event and reward classes
class GamificationEvent {
  final GamificationEventType type;
  final String userId;
  final Map<String, dynamic> data;
  final DateTime timestamp;

  const GamificationEvent({
    required this.type,
    required this.userId,
    required this.data,
    required this.timestamp,
  });
}

class GamificationReward {
  final RewardType type;
  final dynamic value;
  final String description;

  const GamificationReward({
    required this.type,
    required this.value,
    required this.description,
  });
}

class ChallengeReward {
  final String type;
  final dynamic value;

  const ChallengeReward({
    required this.type,
    required this.value,
  });
}

class LevelUpResult {
  final String userId;
  final int previousLevel;
  final int newLevel;
  final int pointsRequired;
  final List<LevelUpReward> rewards;

  const LevelUpResult({
    required this.userId,
    required this.previousLevel,
    required this.newLevel,
    required this.pointsRequired,
    required this.rewards,
  });
}

class LevelUpReward {
  final RewardType type;
  final dynamic value;
  final String description;

  const LevelUpReward({
    required this.type,
    required this.value,
    required this.description,
  });
}

class StreakUpdate {
  final StreakType type;
  final int newValue;
  final int previousValue;
  final bool maintained;

  const StreakUpdate({
    required this.type,
    required this.newValue,
    required this.previousValue,
    required this.maintained,
  });
}

class GamificationPreferences {
  final bool notificationsEnabled;
  final bool leaderboardVisible;
  final Set<AchievementCategory> preferredCategories;

  const GamificationPreferences({
    this.notificationsEnabled = true,
    this.leaderboardVisible = true,
    this.preferredCategories = const {},
  });
}

// Enums for gamification
enum GamificationAction {
  postCreated,
  postLiked,
  postShared,
  commentAdded,
  friendAdded,
  messagesSent,
  profileUpdated,
  dailyLogin,
}

enum GamificationEventType {
  achievementUnlocked,
  badgeEarned,
  challengeProgress,
  challengeCompleted,
  levelUp,
  streakUpdated,
}

enum AchievementCategory {
  milestone,
  social,
  communication,
  creativity,
  consistency,
  special,
}

enum AchievementRarity {
  common,
  uncommon,
  rare,
  epic,
  legendary,
}

enum BadgeCategory {
  engagement,
  networking,
  communication,
  creativity,
  consistency,
  leadership,
}

enum BadgeTier {
  bronze,
  silver,
  gold,
  platinum,
  diamond,
}

enum ChallengeCategory {
  engagement,
  networking,
  communication,
  creativity,
  consistency,
  growth,
}

enum ChallengeDifficulty {
  easy,
  medium,
  hard,
  expert,
}

enum ChallengeStatus {
  active,
  completed,
  expired,
  abandoned,
}

enum RewardType {
  points,
  badge,
  achievement,
  item,
  title,
}

enum LeaderboardType {
  topPosters,
  topEngagers,
  topNetworkers,
  topCommunicators,
  overall,
}

enum StreakType {
  dailyActivity,
  posting,
  engagement,
  messaging,
}
