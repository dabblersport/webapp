import 'dart:async';
import 'dart:math' as math;
import 'package:flutter/foundation.dart';
import 'package:geolocator/geolocator.dart';
import 'package:dabbler/core/utils/either.dart';
import 'package:dabbler/core/services/analytics/analytics_service.dart';
import 'package:dabbler/core/services/storage_service.dart';
import '../../domain/repositories/social_repository.dart';
import 'package:dabbler/data/models/user_model.dart';

/// Service for advanced user discovery with intelligent matching algorithms
class UserDiscoveryService {
  final SocialRepository _repository;
  final StorageService _storageService;
  final AnalyticsService _analyticsService;

  // Search and discovery caches
  final Map<String, List<UserModel>> _searchCache = {};
  final Map<String, DateTime> _cacheTimestamps = {};
  final List<String> _searchHistory = [];
  
  // Discovery algorithms configuration
  static const Duration _cacheExpiry = Duration(minutes: 15);
  static const int _maxSearchHistory = 50;
  
  // Scoring weights for user matching
  static const double _locationWeight = 0.25;
  static const double _sportsInterestsWeight = 0.3;
  static const double _skillLevelWeight = 0.2;
  static const double _activityLevelWeight = 0.15;
  static const double _mutualConnectionsWeight = 0.1;

  // Privacy and filtering
  final Set<String> _blockedUsers = {};
  final Set<String> _hiddenUsers = {};
  bool _respectPrivacySettings = true;

  UserDiscoveryService({
    required SocialRepository repository,
    required StorageService storageService,
    required AnalyticsService analyticsService,
  })  : _repository = repository,
        _storageService = storageService,
        _analyticsService = analyticsService {
    _initializeService();
  }

  void _initializeService() {
    _loadSearchHistory();
    _loadUserPreferences();
  }

  /// Search users with advanced filters and algorithms
  Future<Either<String, List<UserModel>>> searchUsers({
    required String query,
    Map<String, dynamic>? filters,
    int limit = 20,
    int offset = 0,
    bool useCache = true,
  }) async {
    try {
      final cacheKey = _buildCacheKey(query, filters, limit, offset);

      // Check cache first
      if (useCache && _isValidCache(cacheKey)) {
        final cachedResults = _searchCache[cacheKey]!;
        
        _analyticsService.trackEvent('user_search_cached', {
          'query': query,
          'results_count': cachedResults.length,
          'filters': filters?.keys.toList() ?? [],
        });

        return Right(cachedResults);
      }

      // Perform search
      final searchResults = await _performAdvancedSearch(
        query: query,
        filters: filters,
        limit: limit,
        offset: offset,
      );

      if (searchResults.isLeft) {
        return searchResults;
      }

      final users = searchResults.right;

      // Apply privacy filtering
      final filteredUsers = _applyPrivacyFilter(users);

      // Apply intelligent ranking
      final rankedUsers = await _applyIntelligentRanking(
        users: filteredUsers,
        query: query,
        filters: filters,
      );

      // Cache results
      _cacheResults(cacheKey, rankedUsers);

      // Update search history
      _updateSearchHistory(query);

      // Track analytics
      _analyticsService.trackEvent('user_search_completed', {
        'query': query,
        'results_count': rankedUsers.length,
        'filters': filters?.keys.toList() ?? [],
        'from_cache': false,
      });

      return Right(rankedUsers);
    } catch (e) {
      debugPrint('Error searching users: $e');
      return Left('Failed to search users: ${e.toString()}');
    }
  }

  /// Discover users based on location proximity
  Future<Either<String, List<UserModel>>> discoverNearbyUsers({
    double? latitude,
    double? longitude,
    double radiusKm = 25.0,
    int limit = 20,
    Map<String, dynamic>? preferences,
  }) async {
    try {
      Position? currentPosition;

      // Get location
      if (latitude != null && longitude != null) {
        currentPosition = Position(
          latitude: latitude,
          longitude: longitude,
          timestamp: DateTime.now(),
          accuracy: 0,
          altitude: 0,
          heading: 0,
          speed: 0,
          speedAccuracy: 0,
        );
      } else {
        final locationResult = await _getCurrentLocation();
        if (locationResult.isLeft) {
          return Left(locationResult.left);
        }
        currentPosition = locationResult.right;
      }

      // Search for nearby users
      final nearbyResult = await _repository.getUsersNearLocation(
        latitude: currentPosition.latitude,
        longitude: currentPosition.longitude,
        radiusKm: radiusKm,
        limit: limit * 2, // Get more for better filtering
      );

      if (nearbyResult.isLeft) {
        return Left(nearbyResult.left);
      }

      final nearbyUsers = nearbyResult.right;

      // Apply privacy and blocking filters
      final filteredUsers = _applyPrivacyFilter(nearbyUsers);

      // Apply location-based ranking
      final rankedUsers = _rankUsersByLocation(
        users: filteredUsers,
        currentPosition: currentPosition,
        preferences: preferences,
      );

      // Take only requested limit
      final finalUsers = rankedUsers.take(limit).toList();

      // Track analytics
      _analyticsService.trackEvent('nearby_users_discovered', {
        'radius_km': radiusKm,
        'results_count': finalUsers.length,
        'user_latitude': currentPosition.latitude,
        'user_longitude': currentPosition.longitude,
      });

      return Right(finalUsers);
    } catch (e) {
      debugPrint('Error discovering nearby users: $e');
      return Left('Failed to discover nearby users: ${e.toString()}');
    }
  }

  /// Discover users based on sports interests
  Future<Either<String, List<UserModel>>> discoverBySportsInterests({
    List<String>? sportsInterests,
    int limit = 20,
    String skillLevelFilter = 'any',
  }) async {
    try {
      // Get current user's sports interests if not provided
      List<String> userSports = sportsInterests ?? [];
      if (userSports.isEmpty) {
        final currentUserResult = await _repository.getCurrentUser();
        if (currentUserResult.isRight) {
          userSports = currentUserResult.right.sportsInterests ?? [];
        }
      }

      if (userSports.isEmpty) {
        return Left('No sports interests specified');
      }

      // Search for users with similar sports interests
      final sportsResult = await _repository.getUsersBySportsInterests(
        sportsInterests: userSports,
        skillLevelFilter: skillLevelFilter,
        limit: limit * 2,
      );

      if (sportsResult.isLeft) {
        return Left(sportsResult.left);
      }

      final sportsUsers = sportsResult.right;

      // Apply privacy filtering
      final filteredUsers = _applyPrivacyFilter(sportsUsers);

      // Rank by sports interest similarity
      final rankedUsers = _rankUsersBySportsInterests(
        users: filteredUsers,
        userSports: userSports,
        skillLevelFilter: skillLevelFilter,
      );

      final finalUsers = rankedUsers.take(limit).toList();

      _analyticsService.trackEvent('sports_discovery_completed', {
        'sports_interests': userSports,
        'skill_level_filter': skillLevelFilter,
        'results_count': finalUsers.length,
      });

      return Right(finalUsers);
    } catch (e) {
      debugPrint('Error discovering users by sports: $e');
      return Left('Failed to discover users by sports: ${e.toString()}');
    }
  }

  /// Discover users with matching skill levels
  Future<Either<String, List<UserModel>>> discoverBySkillLevel({
    required String sport,
    required String skillLevel,
    bool allowDifferentLevels = true,
    int limit = 20,
  }) async {
    try {
      final skillResult = await _repository.getUsersBySkillLevel(
        sport: sport,
        skillLevel: skillLevel,
        includeSimilarLevels: allowDifferentLevels,
        limit: limit * 2,
      );

      if (skillResult.isLeft) {
        return Left(skillResult.left);
      }

      final skillUsers = skillResult.right;

      // Apply privacy filtering
      final filteredUsers = _applyPrivacyFilter(skillUsers);

      // Rank by skill compatibility
      final rankedUsers = _rankUsersBySkillCompatibility(
        users: filteredUsers,
        targetSport: sport,
        targetSkillLevel: skillLevel,
        allowDifferent: allowDifferentLevels,
      );

      final finalUsers = rankedUsers.take(limit).toList();

      _analyticsService.trackEvent('skill_level_discovery_completed', {
        'sport': sport,
        'skill_level': skillLevel,
        'allow_different': allowDifferentLevels,
        'results_count': finalUsers.length,
      });

      return Right(finalUsers);
    } catch (e) {
      debugPrint('Error discovering users by skill level: $e');
      return Left('Failed to discover users by skill level: ${e.toString()}');
    }
  }

  /// Get personalized user recommendations
  Future<Either<String, List<UserModel>>> getPersonalizedRecommendations({
    int limit = 15,
    Map<String, dynamic>? preferences,
  }) async {
    try {
      // Get current user profile
      final currentUserResult = await _repository.getCurrentUser();
      if (currentUserResult.isLeft) {
        return Left('Unable to get current user profile');
      }

      final currentUser = currentUserResult.right;

      // Get potential matches from multiple sources
      final candidates = await _gatherRecommendationCandidates(
        currentUser: currentUser,
        limit: limit * 3, // Get more candidates for better selection
      );

      if (candidates.isLeft) {
        return Left(candidates.left);
      }

      final users = candidates.right;

      // Apply comprehensive ranking algorithm
      final scoredUsers = await _scoreUsersComprehensively(
        users: users,
        currentUser: currentUser,
        preferences: preferences,
      );

      // Sort by score and take top results
      scoredUsers.sort((a, b) => b.score.compareTo(a.score));
      final recommendations = scoredUsers
          .take(limit)
          .map((scored) => scored.user)
          .toList();

      _analyticsService.trackEvent('personalized_recommendations_generated', {
        'recommendations_count': recommendations.length,
        'candidate_count': users.length,
        'user_id': currentUser.id,
      });

      return Right(recommendations);
    } catch (e) {
      debugPrint('Error getting personalized recommendations: $e');
      return Left('Failed to get recommendations: ${e.toString()}');
    }
  }

  /// Get search suggestions based on history and trends
  Future<Either<String, List<String>>> getSearchSuggestions({
    String? partialQuery,
    int limit = 10,
  }) async {
    try {
      final suggestions = <String>[];

      // Add from search history
      if (partialQuery != null && partialQuery.isNotEmpty) {
        final historySuggestions = _searchHistory
            .where((query) => query.toLowerCase().contains(partialQuery.toLowerCase()))
            .take(5)
            .toList();
        suggestions.addAll(historySuggestions);
      } else {
        // Add recent searches
        suggestions.addAll(_searchHistory.take(3));
      }

      // Get trending sports and interests
      final trendingResult = await _repository.getTrendingInterests();
      if (trendingResult.isRight) {
        final trending = trendingResult.right;
        
        if (partialQuery != null && partialQuery.isNotEmpty) {
          final filteredTrending = trending
              .where((trend) => trend.toLowerCase().contains(partialQuery.toLowerCase()))
              .take(5)
              .toList();
          suggestions.addAll(filteredTrending);
        } else {
          suggestions.addAll(trending.take(7));
        }
      }

      // Remove duplicates and limit
      final uniqueSuggestions = suggestions.toSet().take(limit).toList();

      return Right(uniqueSuggestions);
    } catch (e) {
      debugPrint('Error getting search suggestions: $e');
      return Left('Failed to get search suggestions: ${e.toString()}');
    }
  }

  /// Update user discovery preferences
  Future<Either<String, bool>> updateDiscoveryPreferences({
    required Map<String, dynamic> preferences,
  }) async {
    try {
      await _storageService.saveDiscoveryPreferences(preferences);
      
      // Update privacy settings
      _respectPrivacySettings = preferences['respect_privacy'] ?? true;
      
      _analyticsService.trackEvent('discovery_preferences_updated', {
        'preferences': preferences.keys.toList(),
        'respect_privacy': _respectPrivacySettings,
      });

      return Right(true);
    } catch (e) {
      debugPrint('Error updating discovery preferences: $e');
      return Left('Failed to update preferences: ${e.toString()}');
    }
  }

  /// Hide a user from discovery results
  Future<Either<String, bool>> hideUserFromDiscovery({
    required String userId,
  }) async {
    try {
      _hiddenUsers.add(userId);
      
      await _storageService.addHiddenUser(userId);
      
      // Clear affected caches
      _clearUserFromCaches(userId);

      _analyticsService.trackEvent('user_hidden_from_discovery', {
        'hidden_user_id': userId,
      });

      return Right(true);
    } catch (e) {
      debugPrint('Error hiding user: $e');
      return Left('Failed to hide user: ${e.toString()}');
    }
  }

  /// Clear search history
  Future<Either<String, bool>> clearSearchHistory() async {
    try {
      _searchHistory.clear();
      await _storageService.clearSearchHistory();

      _analyticsService.trackEvent('search_history_cleared');

      return Right(true);
    } catch (e) {
      debugPrint('Error clearing search history: $e');
      return Left('Failed to clear search history: ${e.toString()}');
    }
  }

  Future<Either<String, List<UserModel>>> _performAdvancedSearch({
    required String query,
    Map<String, dynamic>? filters,
    required int limit,
    required int offset,
  }) async {
    // Perform the actual search via repository
    return await _repository.searchUsers(
      query: query,
      filters: filters,
      limit: limit,
      offset: offset,
    );
  }

  Future<List<UserModel>> _applyIntelligentRanking({
    required List<UserModel> users,
    required String query,
    Map<String, dynamic>? filters,
  }) async {
    try {
      final currentUserResult = await _repository.getCurrentUser();
      if (currentUserResult.isLeft) {
        return users; // Return unranked if can't get current user
      }

      final currentUser = currentUserResult.right;
      final scoredUsers = <_ScoredUser>[];

      for (final user in users) {
        double score = 0.0;

        // Text relevance score (40%)
        score += _calculateTextRelevanceScore(user, query) * 0.4;

        // Interest similarity score (25%)
        score += _calculateInterestSimilarityScore(currentUser, user) * 0.25;

        // Activity level compatibility (15%)
        score += _calculateActivityCompatibilityScore(currentUser, user) * 0.15;

        // Recent activity boost (10%)
        score += _calculateRecentActivityScore(user) * 0.1;

        // Mutual connections bonus (10%)
        score += await _calculateMutualConnectionsScore(currentUser.id, user.id) * 0.1;

        scoredUsers.add(_ScoredUser(user: user, score: score));
      }

      // Sort by score descending
      scoredUsers.sort((a, b) => b.score.compareTo(a.score));

      return scoredUsers.map((scored) => scored.user).toList();
    } catch (e) {
      debugPrint('Error applying intelligent ranking: $e');
      return users;
    }
  }

  List<UserModel> _applyPrivacyFilter(List<UserModel> users) {
    if (!_respectPrivacySettings) return users;

    return users.where((user) {
      // Filter out blocked and hidden users
      if (_blockedUsers.contains(user.id) || _hiddenUsers.contains(user.id)) {
        return false;
      }

      // Respect user's privacy settings
      if (user.privacySettings?['discoverable'] == false) {
        return false;
      }

      return true;
    }).toList();
  }

  Future<Either<String, Position>> _getCurrentLocation() async {
    try {
      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        return Left('Location services are disabled');
      }

      // Check permissions
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          return Left('Location permissions are denied');
        }
      }

      if (permission == LocationPermission.deniedForever) {
        return Left('Location permissions are permanently denied');
      }

      // Get current position
      final position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
      );

      return Right(position);
    } catch (e) {
      return Left('Failed to get location: ${e.toString()}');
    }
  }

  List<UserModel> _rankUsersByLocation({
    required List<UserModel> users,
    required Position currentPosition,
    Map<String, dynamic>? preferences,
  }) {
    final scoredUsers = <_ScoredUser>[];

    for (final user in users) {
      if (user.location == null) {
        scoredUsers.add(_ScoredUser(user: user, score: 0.0));
        continue;
      }

      final distance = Geolocator.distanceBetween(
        currentPosition.latitude,
        currentPosition.longitude,
        user.location!['latitude'],
        user.location!['longitude'],
      ) / 1000; // Convert to kilometers

      // Score based on proximity (closer = higher score)
      double score = math.max(0.0, (50.0 - distance) / 50.0);

      // Boost score for users in same city/area
      if (distance < 10) {
        score *= 1.2;
      }

      scoredUsers.add(_ScoredUser(user: user, score: score));
    }

    scoredUsers.sort((a, b) => b.score.compareTo(a.score));
    return scoredUsers.map((scored) => scored.user).toList();
  }

  List<UserModel> _rankUsersBySportsInterests({
    required List<UserModel> users,
    required List<String> userSports,
    required String skillLevelFilter,
  }) {
    final scoredUsers = <_ScoredUser>[];

    for (final user in users) {
      double score = 0.0;

      // Calculate sports overlap
      final userSportsSet = userSports.toSet();
      final otherSportsSet = (user.sportsInterests ?? []).toSet();
      final commonSports = userSportsSet.intersection(otherSportsSet);

      if (commonSports.isNotEmpty) {
        score = commonSports.length / userSportsSet.length;
      }

      // Boost for skill level compatibility
      if (skillLevelFilter != 'any' && user.skillLevels != null) {
        for (final sport in commonSports) {
          final userLevel = user.skillLevels![sport];
          if (userLevel == skillLevelFilter) {
            score *= 1.3;
          }
        }
      }

      scoredUsers.add(_ScoredUser(user: user, score: score));
    }

    scoredUsers.sort((a, b) => b.score.compareTo(a.score));
    return scoredUsers.map((scored) => scored.user).toList();
  }

  List<UserModel> _rankUsersBySkillCompatibility({
    required List<UserModel> users,
    required String targetSport,
    required String targetSkillLevel,
    required bool allowDifferent,
  }) {
    final skillLevels = ['beginner', 'intermediate', 'advanced', 'expert'];
    final targetLevelIndex = skillLevels.indexOf(targetSkillLevel);

    final scoredUsers = <_ScoredUser>[];

    for (final user in users) {
      double score = 0.0;

      if (user.skillLevels?.containsKey(targetSport) == true) {
        final userLevel = user.skillLevels![targetSport]!;
        final userLevelIndex = skillLevels.indexOf(userLevel);

        if (userLevelIndex >= 0 && targetLevelIndex >= 0) {
          if (userLevel == targetSkillLevel) {
            score = 1.0; // Perfect match
          } else if (allowDifferent) {
            // Score based on skill level proximity
            final difference = (userLevelIndex - targetLevelIndex).abs();
            score = math.max(0.0, (3 - difference) / 3.0);
          }
        }
      }

      scoredUsers.add(_ScoredUser(user: user, score: score));
    }

    scoredUsers.sort((a, b) => b.score.compareTo(a.score));
    return scoredUsers.map((scored) => scored.user).toList();
  }

  Future<Either<String, List<UserModel>>> _gatherRecommendationCandidates({
    required UserModel currentUser,
    required int limit,
  }) async {
    final allCandidates = <UserModel>[];

    try {
      // Get users with similar sports interests
      if (currentUser.sportsInterests != null && currentUser.sportsInterests!.isNotEmpty) {
        final sportsResult = await _repository.getUsersBySportsInterests(
          sportsInterests: currentUser.sportsInterests!,
          limit: limit,
        );
        if (sportsResult.isRight) {
          allCandidates.addAll(sportsResult.right);
        }
      }

      // Get nearby users
      if (currentUser.location != null) {
        final nearbyResult = await _repository.getUsersNearLocation(
          latitude: currentUser.location!['latitude'],
          longitude: currentUser.location!['longitude'],
          radiusKm: 50.0,
          limit: limit,
        );
        if (nearbyResult.isRight) {
          allCandidates.addAll(nearbyResult.right);
        }
      }

      // Get users with similar activity levels
      final activityResult = await _repository.getUsersByActivityLevel(
        activityLevel: currentUser.activityLevel ?? 'moderate',
        limit: limit ~/ 2,
      );
      if (activityResult.isRight) {
        allCandidates.addAll(activityResult.right);
      }

      // Remove duplicates and current user
      final uniqueCandidates = <String, UserModel>{};
      for (final user in allCandidates) {
        if (user.id != currentUser.id) {
          uniqueCandidates[user.id] = user;
        }
      }

      return Right(uniqueCandidates.values.toList());
    } catch (e) {
      return Left('Failed to gather recommendation candidates: ${e.toString()}');
    }
  }

  Future<List<_ScoredUser>> _scoreUsersComprehensively({
    required List<UserModel> users,
    required UserModel currentUser,
    Map<String, dynamic>? preferences,
  }) async {
    final scoredUsers = <_ScoredUser>[];

    for (final user in users) {
      double totalScore = 0.0;

      // Location proximity score
      if (currentUser.location != null && user.location != null) {
        final distance = Geolocator.distanceBetween(
          currentUser.location!['latitude'],
          currentUser.location!['longitude'],
          user.location!['latitude'],
          user.location!['longitude'],
        ) / 1000;
        
        final locationScore = math.max(0.0, (100.0 - distance) / 100.0);
        totalScore += locationScore * _locationWeight;
      }

      // Sports interests similarity
      final sportsScore = _calculateSportsInterestsSimilarity(
        currentUser.sportsInterests ?? [],
        user.sportsInterests ?? [],
      );
      totalScore += sportsScore * _sportsInterestsWeight;

      // Skill level compatibility
      final skillScore = _calculateSkillLevelCompatibility(
        currentUser.skillLevels ?? {},
        user.skillLevels ?? {},
      );
      totalScore += skillScore * _skillLevelWeight;

      // Activity level compatibility
      final activityScore = _calculateActivityLevelCompatibility(
        currentUser.activityLevel ?? 'moderate',
        user.activityLevel ?? 'moderate',
      );
      totalScore += activityScore * _activityLevelWeight;

      // Mutual connections bonus
      final mutualScore = await _calculateMutualConnectionsScore(
        currentUser.id,
        user.id,
      );
      totalScore += mutualScore * _mutualConnectionsWeight;

      scoredUsers.add(_ScoredUser(user: user, score: totalScore));
    }

    return scoredUsers;
  }

  double _calculateTextRelevanceScore(UserModel user, String query) {
    final queryLower = query.toLowerCase();
    double score = 0.0;

    // Check username match
    if (user.username.toLowerCase().contains(queryLower)) {
      score += 0.4;
    }

    // Check display name match
    if (user.displayName.toLowerCase().contains(queryLower) == true) {
      score += 0.3;
    }

    // Check bio match
    if (user.bio?.toLowerCase().contains(queryLower) == true) {
      score += 0.2;
    }

    // Check sports interests match
    final sportsMatch = user.sportsInterests?.any(
      (sport) => sport.toLowerCase().contains(queryLower),
    ) ?? false;
    if (sportsMatch) {
      score += 0.1;
    }

    return math.min(1.0, score);
  }

  double _calculateInterestSimilarityScore(UserModel currentUser, UserModel otherUser) {
    final currentInterests = (currentUser.sportsInterests ?? []).toSet();
    final otherInterests = (otherUser.sportsInterests ?? []).toSet();
    
    if (currentInterests.isEmpty || otherInterests.isEmpty) {
      return 0.0;
    }

    final commonInterests = currentInterests.intersection(otherInterests);
    final totalInterests = currentInterests.union(otherInterests);
    
    return commonInterests.length / totalInterests.length;
  }

  double _calculateActivityCompatibilityScore(UserModel currentUser, UserModel otherUser) {
    final activityLevels = ['low', 'moderate', 'high', 'very_high'];
    final currentLevel = activityLevels.indexOf(currentUser.activityLevel ?? 'moderate');
    final otherLevel = activityLevels.indexOf(otherUser.activityLevel ?? 'moderate');
    
    if (currentLevel == -1 || otherLevel == -1) {
      return 0.5;
    }

    final difference = (currentLevel - otherLevel).abs();
    return math.max(0.0, (3 - difference) / 3.0);
  }

  double _calculateRecentActivityScore(UserModel user) {
    if (user.lastActiveAt == null) return 0.0;
    
    final daysSinceActive = DateTime.now().difference(user.lastActiveAt!).inDays;
    
    if (daysSinceActive <= 1) return 1.0;
    if (daysSinceActive <= 7) return 0.7;
    if (daysSinceActive <= 30) return 0.4;
    
    return 0.1;
  }

  Future<double> _calculateMutualConnectionsScore(String userId1, String userId2) async {
    try {
      final mutualResult = await _repository.getMutualConnections(userId1, userId2);
      if (mutualResult.isLeft) return 0.0;
      
      final mutualCount = mutualResult.right.length;
      return math.min(1.0, mutualCount / 10.0); // Normalize to 0-1
    } catch (e) {
      return 0.0;
    }
  }

  double _calculateSportsInterestsSimilarity(List<String> interests1, List<String> interests2) {
    if (interests1.isEmpty || interests2.isEmpty) return 0.0;
    
    final set1 = interests1.toSet();
    final set2 = interests2.toSet();
    final common = set1.intersection(set2);
    final total = set1.union(set2);
    
    return common.length / total.length;
  }

  double _calculateSkillLevelCompatibility(Map<String, String> skills1, Map<String, String> skills2) {
    if (skills1.isEmpty || skills2.isEmpty) return 0.0;
    
    final skillLevels = ['beginner', 'intermediate', 'advanced', 'expert'];
    double totalCompatibility = 0.0;
    int commonSports = 0;
    
    for (final sport in skills1.keys) {
      if (skills2.containsKey(sport)) {
        final level1 = skillLevels.indexOf(skills1[sport] ?? 'beginner');
        final level2 = skillLevels.indexOf(skills2[sport] ?? 'beginner');
        
        if (level1 >= 0 && level2 >= 0) {
          final difference = (level1 - level2).abs();
          final compatibility = math.max(0.0, (3 - difference) / 3.0);
          totalCompatibility += compatibility;
          commonSports++;
        }
      }
    }
    
    return commonSports > 0 ? totalCompatibility / commonSports : 0.0;
  }

  double _calculateActivityLevelCompatibility(String level1, String level2) {
    final activityLevels = ['low', 'moderate', 'high', 'very_high'];
    final index1 = activityLevels.indexOf(level1);
    final index2 = activityLevels.indexOf(level2);
    
    if (index1 == -1 || index2 == -1) return 0.5;
    
    final difference = (index1 - index2).abs();
    return math.max(0.0, (3 - difference) / 3.0);
  }

  String _buildCacheKey(String query, Map<String, dynamic>? filters, int limit, int offset) {
    final filterStr = filters?.toString() ?? 'none';
    return 'search_${query}_${filterStr}_${limit}_$offset';
  }

  bool _isValidCache(String cacheKey) {
    if (!_searchCache.containsKey(cacheKey)) return false;
    
    final cacheTime = _cacheTimestamps[cacheKey];
    if (cacheTime == null) return false;
    
    return DateTime.now().difference(cacheTime).compareTo(_cacheExpiry) < 0;
  }

  void _cacheResults(String cacheKey, List<UserModel> users) {
    _searchCache[cacheKey] = users;
    _cacheTimestamps[cacheKey] = DateTime.now();
  }

  void _updateSearchHistory(String query) {
    // Remove query if it exists
    _searchHistory.remove(query);
    
    // Add to beginning
    _searchHistory.insert(0, query);
    
    // Keep only recent searches
    if (_searchHistory.length > _maxSearchHistory) {
      _searchHistory.removeRange(_maxSearchHistory, _searchHistory.length);
    }
    
    // Save to storage
    _storageService.saveSearchHistory(_searchHistory);
  }

  void _clearUserFromCaches(String userId) {
    for (final key in _searchCache.keys.toList()) {
      final users = _searchCache[key]!;
      users.removeWhere((user) => user.id == userId);
      
      if (users.isEmpty) {
        _searchCache.remove(key);
        _cacheTimestamps.remove(key);
      }
    }
  }

  Future<void> _loadSearchHistory() async {
    try {
      final history = await _storageService.getSearchHistory();
      _searchHistory.addAll(history);
    } catch (e) {
      debugPrint('Error loading search history: $e');
    }
  }

  Future<void> _loadUserPreferences() async {
    try {
      final blockedUsers = await _storageService.getBlockedUsers();
      _blockedUsers.addAll(blockedUsers);
      
      final hiddenUsers = await _storageService.getHiddenUsers();
      _hiddenUsers.addAll(hiddenUsers);
      
      final preferences = await _storageService.getDiscoveryPreferences();
      _respectPrivacySettings = preferences['respect_privacy'] ?? true;
    } catch (e) {
      debugPrint('Error loading user preferences: $e');
    }
  }

  /// Get discovery statistics
  Map<String, dynamic> getDiscoveryStats() {
    return {
      'search_cache_size': _searchCache.length,
      'search_history_size': _searchHistory.length,
      'blocked_users_count': _blockedUsers.length,
      'hidden_users_count': _hiddenUsers.length,
      'respect_privacy_settings': _respectPrivacySettings,
    };
  }

  /// Clear all caches
  void clearCaches() {
    _searchCache.clear();
    _cacheTimestamps.clear();
  }

  /// Dispose service and cleanup
  void dispose() {
    clearCaches();
    _searchHistory.clear();
    _blockedUsers.clear();
    _hiddenUsers.clear();
  }
}

class _ScoredUser {
  final UserModel user;
  final double score;

  _ScoredUser({required this.user, required this.score});
}
