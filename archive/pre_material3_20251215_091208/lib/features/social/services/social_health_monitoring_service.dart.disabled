import 'dart:async';
import 'dart:math' as math;

import 'package:dabbler/core/utils/either.dart';
import 'package:dabbler/core/services/storage_service.dart';
import 'package:dabbler/core/services/analytics/analytics_service.dart';
import 'social_analytics_service.dart';

/// Service for monitoring social feature health and user engagement
class SocialHealthMonitoringService {
  final AnalyticsService _analytics;
  final StorageService _storage;
  final SocialAnalyticsService _socialAnalytics;

  // Monitoring timers
  Timer? _realTimeMonitoringTimer;
  Timer? _dailyAggregationTimer;
  Timer? _weeklyAnalysisTimer;

  // Cache for metrics
  final Map<String, SocialHealthMetrics> _metricsCache = {};
  final Map<String, DateTime> _lastUpdateTimes = {};

  // Monitoring configuration
  static const Duration _realTimeInterval = Duration(minutes: 5);
  static const Duration _dailyInterval = Duration(hours: 24);
  static const Duration _weeklyInterval = Duration(days: 7);

  SocialHealthMonitoringService({
    required AnalyticsService analytics,
    required StorageService storage,
    required SocialAnalyticsService socialAnalytics,
  })  : _analytics = analytics,
        _storage = storage,
        _socialAnalytics = socialAnalytics {
    _initializeMonitoring();
  }

  /// Initialize monitoring timers
  void _initializeMonitoring() {
    // Real-time monitoring every 5 minutes
    _realTimeMonitoringTimer = Timer.periodic(_realTimeInterval, (_) async {
      await _performRealTimeHealthCheck();
    });

    // Daily aggregation
    _dailyAggregationTimer = Timer.periodic(_dailyInterval, (_) async {
      await _performDailyAggregation();
    });

    // Weekly analysis
    _weeklyAnalysisTimer = Timer.periodic(_weeklyInterval, (_) async {
      await _performWeeklyAnalysis();
    });
  }

  /// Get current social health metrics
  Future<Either<String, SocialHealthMetrics>> getSocialHealthMetrics({
    Duration period = const Duration(days: 30),
    bool forceRefresh = false,
  }) async {
    try {
      final cacheKey = 'social_health_${period.inDays}';
      final now = DateTime.now();

      // Check cache validity
      if (!forceRefresh && 
          _metricsCache.containsKey(cacheKey) &&
          _lastUpdateTimes[cacheKey] != null &&
          now.difference(_lastUpdateTimes[cacheKey]!).inMinutes < 30) {
        return Right(_metricsCache[cacheKey]!);
      }

      // Calculate fresh metrics
      final activeUsers = await _calculateActiveUsers(period);
      final contentMetrics = await _calculateContentMetrics(period);
      final engagementMetrics = await _calculateEngagementMetrics(period);
      final socialInteractionMetrics = await _calculateSocialInteractionMetrics(period);
      final healthScores = await _calculateHealthScores(
        activeUsers, contentMetrics, engagementMetrics, socialInteractionMetrics);

      final metrics = SocialHealthMetrics(
        period: period,
        calculatedAt: now,
        activeUsers: activeUsers,
        contentMetrics: contentMetrics,
        engagementMetrics: engagementMetrics,
        socialInteractionMetrics: socialInteractionMetrics,
        healthScores: healthScores,
        trends: await _calculateTrends(period),
        insights: await _generateHealthInsights(
          activeUsers, contentMetrics, engagementMetrics, socialInteractionMetrics),
      );

      // Cache the metrics
      _metricsCache[cacheKey] = metrics;
      _lastUpdateTimes[cacheKey] = now;

      // Store for historical analysis
      await _storeHistoricalMetrics(metrics);

      return Right(metrics);
    } catch (e) {
      return Left('Failed to get social health metrics: $e');
    }
  }

  /// Calculate active user metrics
  Future<ActiveUserMetrics> _calculateActiveUsers(Duration period) async {
    final now = DateTime.now();
    final startDate = now.subtract(period);

    // Get all user activity events
    final events = await _getActivityEvents(startDate, now);
    final userActivities = <String, Set<DateTime>>{};

    // Group events by user and date
    for (final event in events) {
      final userId = event.userId;
      final date = DateTime(event.timestamp.year, event.timestamp.month, event.timestamp.day);
      
      userActivities.putIfAbsent(userId, () => <DateTime>{}).add(date);
    }

    // Calculate DAU, WAU, MAU
    final today = DateTime(now.year, now.month, now.day);
    final weekAgo = today.subtract(const Duration(days: 7));
    final monthAgo = today.subtract(const Duration(days: 30));

    final dailyActiveUsers = userActivities.entries
        .where((entry) => entry.value.contains(today))
        .length;

    final weeklyActiveUsers = userActivities.entries
        .where((entry) => entry.value.any((date) => date.isAfter(weekAgo) || date.isAtSameMomentAs(weekAgo)))
        .length;

    final monthlyActiveUsers = userActivities.entries
        .where((entry) => entry.value.any((date) => date.isAfter(monthAgo) || date.isAtSameMomentAs(monthAgo)))
        .length;

    // Calculate retention metrics
    final retentionMetrics = await _calculateUserRetention(userActivities, period);

    // Calculate session metrics
    final sessionMetrics = await _calculateSessionMetrics(events);

    return ActiveUserMetrics(
      period: period,
      dailyActiveUsers: dailyActiveUsers,
      weeklyActiveUsers: weeklyActiveUsers,
      monthlyActiveUsers: monthlyActiveUsers,
      newUsers: await _countNewUsers(period),
      returningUsers: await _countReturningUsers(period),
      retentionMetrics: retentionMetrics,
      sessionMetrics: sessionMetrics,
      userGrowthRate: await _calculateUserGrowthRate(period),
      churnRate: await _calculateChurnRate(period),
    );
  }

  /// Calculate content creation and interaction metrics
  Future<ContentMetrics> _calculateContentMetrics(Duration period) async {
    final now = DateTime.now();
    final startDate = now.subtract(period);

    final postEvents = await _getContentEvents(startDate, now, 'post');
    final commentEvents = await _getContentEvents(startDate, now, 'comment');
    final messageEvents = await _getContentEvents(startDate, now, 'message');

    // Post metrics
    final postCreationRate = postEvents.length / period.inDays;
    final postsWithEngagement = postEvents.where((event) => 
        (event.data['likes'] as int? ?? 0) > 0 ||
        (event.data['comments'] as int? ?? 0) > 0 ||
        (event.data['shares'] as int? ?? 0) > 0).length;
    final postEngagementRate = postEvents.isEmpty ? 0.0 : postsWithEngagement / postEvents.length;

    // Comment metrics
    final commentCreationRate = commentEvents.length / period.inDays;
    final averageCommentsPerPost = postEvents.isEmpty ? 0.0 : commentEvents.length / postEvents.length;

    // Message metrics
    final messagesSentPerDay = messageEvents.length / period.inDays;
    final messageDeliverySuccess = await _calculateMessageDeliverySuccess(messageEvents);

    // Content quality scores
    final qualityScores = await _calculateContentQualityScores(postEvents, commentEvents);

    return ContentMetrics(
      period: period,
      postCreationRate: postCreationRate,
      commentCreationRate: commentCreationRate,
      messagesSentPerDay: messagesSentPerDay,
      postEngagementRate: postEngagementRate,
      averageCommentsPerPost: averageCommentsPerPost,
      messageDeliverySuccessRate: messageDeliverySuccess,
      contentQualityScores: qualityScores,
      viralContentCount: await _countViralContent(period),
      flaggedContentRate: await _calculateFlaggedContentRate(period),
    );
  }

  /// Calculate overall engagement metrics
  Future<EngagementMetrics> _calculateEngagementMetrics(Duration period) async {
    final now = DateTime.now();
    final startDate = now.subtract(period);

    final engagementEvents = await _getEngagementEvents(startDate, now);

    // Like metrics
    final likeEvents = engagementEvents.where((e) => e.type == 'like').toList();
    final likesPerDay = likeEvents.length / period.inDays;
    final likesPerUser = await _calculateLikesPerUser(likeEvents);

    // Comment metrics
    final commentEvents = engagementEvents.where((e) => e.type == 'comment').toList();
    final commentsPerDay = commentEvents.length / period.inDays;
    
    // Share metrics
    final shareEvents = engagementEvents.where((e) => e.type == 'share').toList();
    final sharesPerDay = shareEvents.length / period.inDays;

    // Reaction metrics
    final reactionEvents = engagementEvents.where((e) => e.type == 'reaction').toList();
    final reactionsPerDay = reactionEvents.length / period.inDays;

    // Time-based engagement
    final timeBasedEngagement = await _calculateTimeBasedEngagement(engagementEvents);

    // Engagement depth
    final engagementDepth = await _calculateEngagementDepth(engagementEvents);

    return EngagementMetrics(
      period: period,
      likesPerDay: likesPerDay,
      commentsPerDay: commentsPerDay,
      sharesPerDay: sharesPerDay,
      reactionsPerDay: reactionsPerDay,
      averageLikesPerUser: likesPerUser,
      timeBasedEngagement: timeBasedEngagement,
      engagementDepth: engagementDepth,
      peakEngagementHours: await _findPeakEngagementHours(engagementEvents),
      engagementGrowthRate: await _calculateEngagementGrowthRate(period),
    );
  }

  /// Calculate social interaction metrics
  Future<SocialInteractionMetrics> _calculateSocialInteractionMetrics(Duration period) async {
    final now = DateTime.now();
    final startDate = now.subtract(period);

    // Friend request metrics
    final friendRequestEvents = await _getFriendRequestEvents(startDate, now);
    final friendRequestsSent = friendRequestEvents.where((e) => e.type == 'sent').length;
    final friendRequestsReceived = friendRequestEvents.where((e) => e.type == 'received').length;
    final friendRequestsAccepted = friendRequestEvents.where((e) => e.type == 'accepted').length;
    final acceptanceRate = friendRequestsReceived == 0 ? 0.0 : friendRequestsAccepted / friendRequestsReceived;

    // Messaging metrics
    final messagingMetrics = await _calculateMessagingHealthMetrics(period);

    // Network growth
    final networkGrowth = await _calculateNetworkGrowthMetrics(period);

    return SocialInteractionMetrics(
      period: period,
      friendRequestsSentPerDay: friendRequestsSent / period.inDays,
      friendRequestAcceptanceRate: acceptanceRate,
      messagingMetrics: messagingMetrics,
      networkGrowthMetrics: networkGrowth,
      conversationStartRate: await _calculateConversationStartRate(period),
      responseTimeMetrics: await _calculateResponseTimeMetrics(period),
    );
  }

  /// Calculate overall health scores
  Future<HealthScores> _calculateHealthScores(
    ActiveUserMetrics activeUsers,
    ContentMetrics contentMetrics,
    EngagementMetrics engagementMetrics,
    SocialInteractionMetrics socialMetrics,
  ) async {
    // User activity health (0-100)
    final userActivityScore = _calculateUserActivityScore(activeUsers);

    // Content health (0-100)
    final contentHealthScore = _calculateContentHealthScore(contentMetrics);

    // Engagement health (0-100)
    final engagementHealthScore = _calculateEngagementHealthScore(engagementMetrics);

    // Social network health (0-100)
    final socialNetworkScore = _calculateSocialNetworkScore(socialMetrics);

    // Overall social platform health
    final overallScore = (userActivityScore + contentHealthScore + 
                         engagementHealthScore + socialNetworkScore) / 4;

    return HealthScores(
      overall: overallScore,
      userActivity: userActivityScore,
      contentHealth: contentHealthScore,
      engagementHealth: engagementHealthScore,
      socialNetwork: socialNetworkScore,
      healthTrend: await _calculateHealthTrend(),
    );
  }

  /// Perform real-time health monitoring
  Future<void> _performRealTimeHealthCheck() async {
    try {
      // Check critical metrics
      final criticalIssues = await _detectCriticalIssues();
      
      if (criticalIssues.isNotEmpty) {
        await _handleCriticalIssues(criticalIssues);
      }

      // Update real-time dashboards
      await _updateRealTimeDashboards();

      // Log monitoring event
      await _analytics.trackEvent('social_health_check', {
        'timestamp': DateTime.now().toIso8601String(),
        'critical_issues_count': criticalIssues.length,
      });
    } catch (e) {
      print('Real-time health check failed: $e');
    }
  }

  /// Perform daily aggregation
  Future<void> _performDailyAggregation() async {
    try {
      final yesterday = DateTime.now().subtract(const Duration(days: 1));
      final metrics = await getSocialHealthMetrics(
        period: const Duration(days: 1),
        forceRefresh: true,
      );

      if (metrics.isRight) {
        final metricsData = metrics.rightOrNull();
        if (metricsData != null) {
          await _storeDailyMetrics(metricsData, yesterday);
          await _generateDailyHealthReport(metricsData);
        }
      }
    } catch (e) {
      print('Daily aggregation failed: $e');
    }
  }

  /// Perform weekly analysis
  Future<void> _performWeeklyAnalysis() async {
    try {
      final weeklyMetrics = await getSocialHealthMetrics(
        period: const Duration(days: 7),
        forceRefresh: true,
      );

      if (weeklyMetrics.isRight) {
        final metricsData = weeklyMetrics.rightOrNull();
        if (metricsData != null) {
          await _generateWeeklyHealthReport(metricsData);
          await _updateHealthTrends(metricsData);
        }
      }
    } catch (e) {
      print('Weekly analysis failed: $e');
    }
  }

  // Helper methods for calculations
  double _calculateUserActivityScore(ActiveUserMetrics metrics) {
    // Algorithm to calculate user activity health score
    final dauToMauRatio = metrics.monthlyActiveUsers == 0 ? 0 : 
        metrics.dailyActiveUsers / metrics.monthlyActiveUsers;
    final retentionScore = metrics.retentionMetrics.day7Retention * 100;
    final growthScore = math.max(0, math.min(100, metrics.userGrowthRate * 100));

    return (dauToMauRatio * 30 + retentionScore + growthScore) / 3;
  }

  double _calculateContentHealthScore(ContentMetrics metrics) {
    // Algorithm to calculate content health score
    final engagementScore = metrics.postEngagementRate * 100;
    final qualityScore = metrics.contentQualityScores.overall;
    final viralityBonus = metrics.viralContentCount > 0 ? 10 : 0;
    final moderationPenalty = metrics.flaggedContentRate * 20;

    return math.max(0, math.min(100, 
        (engagementScore + qualityScore + viralityBonus - moderationPenalty) / 2));
  }

  double _calculateEngagementHealthScore(EngagementMetrics metrics) {
    // Algorithm to calculate engagement health score
    final likeScore = math.min(20, metrics.likesPerDay / 100 * 20);
    final commentScore = math.min(20, metrics.commentsPerDay / 50 * 20);
    final shareScore = math.min(20, metrics.sharesPerDay / 20 * 20);
    final depthScore = metrics.engagementDepth.averageDepth * 20;
    final growthScore = math.max(0, math.min(20, metrics.engagementGrowthRate * 20));

    return likeScore + commentScore + shareScore + depthScore + growthScore;
  }

  double _calculateSocialNetworkScore(SocialInteractionMetrics metrics) {
    // Algorithm to calculate social network health score
    final acceptanceScore = metrics.friendRequestAcceptanceRate * 40;
    final messagingScore = metrics.messagingMetrics.healthScore;
    final networkScore = metrics.networkGrowthMetrics.healthScore;
    final conversationScore = math.min(20, metrics.conversationStartRate * 100);

    return (acceptanceScore + messagingScore + networkScore + conversationScore) / 4;
  }

  // Placeholder methods for detailed calculations
  Future<List<ActivityEvent>> _getActivityEvents(DateTime start, DateTime end) async {
    // Implementation would fetch actual activity events from database
    return [];
  }

  Future<List<ContentEvent>> _getContentEvents(DateTime start, DateTime end, String type) async {
    // Implementation would fetch content events
    return [];
  }

  Future<List<EngagementEvent>> _getEngagementEvents(DateTime start, DateTime end) async {
    // Implementation would fetch engagement events
    return [];
  }

  Future<List<FriendRequestEvent>> _getFriendRequestEvents(DateTime start, DateTime end) async {
    // Implementation would fetch friend request events
    return [];
  }

  Future<int> _countNewUsers(Duration period) async => 0;
  Future<int> _countReturningUsers(Duration period) async => 0;
  Future<UserRetentionMetrics> _calculateUserRetention(Map<String, Set<DateTime>> activities, Duration period) async => UserRetentionMetrics.empty();
  Future<SessionMetrics> _calculateSessionMetrics(List<ActivityEvent> events) async => SessionMetrics.empty();
  Future<double> _calculateUserGrowthRate(Duration period) async => 0.0;
  Future<double> _calculateChurnRate(Duration period) async => 0.0;
  Future<double> _calculateMessageDeliverySuccess(List<ContentEvent> events) async => 0.95;
  Future<ContentQualityScores> _calculateContentQualityScores(List<ContentEvent> posts, List<ContentEvent> comments) async => ContentQualityScores.empty();
  Future<int> _countViralContent(Duration period) async => 0;
  Future<double> _calculateFlaggedContentRate(Duration period) async => 0.01;
  Future<double> _calculateLikesPerUser(List<EngagementEvent> events) async => 0.0;
  Future<TimeBasedEngagement> _calculateTimeBasedEngagement(List<EngagementEvent> events) async => TimeBasedEngagement.empty();
  Future<EngagementDepth> _calculateEngagementDepth(List<EngagementEvent> events) async => EngagementDepth.empty();
  Future<List<int>> _findPeakEngagementHours(List<EngagementEvent> events) async => [];
  Future<double> _calculateEngagementGrowthRate(Duration period) async => 0.0;
  Future<MessagingHealthMetrics> _calculateMessagingHealthMetrics(Duration period) async => MessagingHealthMetrics.empty();
  Future<NetworkGrowthMetrics> _calculateNetworkGrowthMetrics(Duration period) async => NetworkGrowthMetrics.empty();
  Future<double> _calculateConversationStartRate(Duration period) async => 0.0;
  Future<ResponseTimeMetrics> _calculateResponseTimeMetrics(Duration period) async => ResponseTimeMetrics.empty();
  Future<HealthTrends> _calculateTrends(Duration period) async => HealthTrends.empty();
  Future<List<String>> _generateHealthInsights(ActiveUserMetrics active, ContentMetrics content, EngagementMetrics engagement, SocialInteractionMetrics social) async => [];
  Future<void> _storeHistoricalMetrics(SocialHealthMetrics metrics) async {}
  Future<double> _calculateHealthTrend() async => 0.0;
  Future<List<CriticalIssue>> _detectCriticalIssues() async => [];
  Future<void> _handleCriticalIssues(List<CriticalIssue> issues) async {}
  Future<void> _updateRealTimeDashboards() async {}
  Future<void> _storeDailyMetrics(SocialHealthMetrics metrics, DateTime date) async {}
  Future<void> _generateDailyHealthReport(SocialHealthMetrics metrics) async {}
  Future<void> _generateWeeklyHealthReport(SocialHealthMetrics metrics) async {}
  Future<void> _updateHealthTrends(SocialHealthMetrics metrics) async {}

  /// Dispose resources
  void dispose() {
    _realTimeMonitoringTimer?.cancel();
    _dailyAggregationTimer?.cancel();
    _weeklyAnalysisTimer?.cancel();
  }
}

// Data models for health monitoring
class SocialHealthMetrics {
  final Duration period;
  final DateTime calculatedAt;
  final ActiveUserMetrics activeUsers;
  final ContentMetrics contentMetrics;
  final EngagementMetrics engagementMetrics;
  final SocialInteractionMetrics socialInteractionMetrics;
  final HealthScores healthScores;
  final HealthTrends trends;
  final List<String> insights;

  const SocialHealthMetrics({
    required this.period,
    required this.calculatedAt,
    required this.activeUsers,
    required this.contentMetrics,
    required this.engagementMetrics,
    required this.socialInteractionMetrics,
    required this.healthScores,
    required this.trends,
    required this.insights,
  });
}

class ActiveUserMetrics {
  final Duration period;
  final int dailyActiveUsers;
  final int weeklyActiveUsers;
  final int monthlyActiveUsers;
  final int newUsers;
  final int returningUsers;
  final UserRetentionMetrics retentionMetrics;
  final SessionMetrics sessionMetrics;
  final double userGrowthRate;
  final double churnRate;

  const ActiveUserMetrics({
    required this.period,
    required this.dailyActiveUsers,
    required this.weeklyActiveUsers,
    required this.monthlyActiveUsers,
    required this.newUsers,
    required this.returningUsers,
    required this.retentionMetrics,
    required this.sessionMetrics,
    required this.userGrowthRate,
    required this.churnRate,
  });
}

class ContentMetrics {
  final Duration period;
  final double postCreationRate;
  final double commentCreationRate;
  final double messagesSentPerDay;
  final double postEngagementRate;
  final double averageCommentsPerPost;
  final double messageDeliverySuccessRate;
  final ContentQualityScores contentQualityScores;
  final int viralContentCount;
  final double flaggedContentRate;

  const ContentMetrics({
    required this.period,
    required this.postCreationRate,
    required this.commentCreationRate,
    required this.messagesSentPerDay,
    required this.postEngagementRate,
    required this.averageCommentsPerPost,
    required this.messageDeliverySuccessRate,
    required this.contentQualityScores,
    required this.viralContentCount,
    required this.flaggedContentRate,
  });
}

class EngagementMetrics {
  final Duration period;
  final double likesPerDay;
  final double commentsPerDay;
  final double sharesPerDay;
  final double reactionsPerDay;
  final double averageLikesPerUser;
  final TimeBasedEngagement timeBasedEngagement;
  final EngagementDepth engagementDepth;
  final List<int> peakEngagementHours;
  final double engagementGrowthRate;

  const EngagementMetrics({
    required this.period,
    required this.likesPerDay,
    required this.commentsPerDay,
    required this.sharesPerDay,
    required this.reactionsPerDay,
    required this.averageLikesPerUser,
    required this.timeBasedEngagement,
    required this.engagementDepth,
    required this.peakEngagementHours,
    required this.engagementGrowthRate,
  });
}

class SocialInteractionMetrics {
  final Duration period;
  final double friendRequestsSentPerDay;
  final double friendRequestAcceptanceRate;
  final MessagingHealthMetrics messagingMetrics;
  final NetworkGrowthMetrics networkGrowthMetrics;
  final double conversationStartRate;
  final ResponseTimeMetrics responseTimeMetrics;

  const SocialInteractionMetrics({
    required this.period,
    required this.friendRequestsSentPerDay,
    required this.friendRequestAcceptanceRate,
    required this.messagingMetrics,
    required this.networkGrowthMetrics,
    required this.conversationStartRate,
    required this.responseTimeMetrics,
  });
}

class HealthScores {
  final double overall;
  final double userActivity;
  final double contentHealth;
  final double engagementHealth;
  final double socialNetwork;
  final double healthTrend;

  const HealthScores({
    required this.overall,
    required this.userActivity,
    required this.contentHealth,
    required this.engagementHealth,
    required this.socialNetwork,
    required this.healthTrend,
  });
}

// Additional data classes with empty() factory methods
class UserRetentionMetrics {
  static UserRetentionMetrics empty() => const UserRetentionMetrics(day1Retention: 0, day7Retention: 0, day30Retention: 0);
  
  final double day1Retention;
  final double day7Retention;
  final double day30Retention;

  const UserRetentionMetrics({
    required this.day1Retention,
    required this.day7Retention,
    required this.day30Retention,
  });
}

class SessionMetrics {
  static SessionMetrics empty() => const SessionMetrics(averageSessionDuration: Duration.zero, sessionsPerUser: 0);

  final Duration averageSessionDuration;
  final double sessionsPerUser;

  const SessionMetrics({
    required this.averageSessionDuration,
    required this.sessionsPerUser,
  });
}

class ContentQualityScores {
  static ContentQualityScores empty() => const ContentQualityScores(overall: 0, readability: 0, engagement: 0, uniqueness: 0);

  final double overall;
  final double readability;
  final double engagement;
  final double uniqueness;

  const ContentQualityScores({
    required this.overall,
    required this.readability,
    required this.engagement,
    required this.uniqueness,
  });
}

class TimeBasedEngagement {
  static TimeBasedEngagement empty() => const TimeBasedEngagement(hourlyPattern: [], weeklyPattern: [], peakHour: 12);

  final List<double> hourlyPattern;
  final List<double> weeklyPattern;
  final int peakHour;

  const TimeBasedEngagement({
    required this.hourlyPattern,
    required this.weeklyPattern,
    required this.peakHour,
  });
}

class EngagementDepth {
  static EngagementDepth empty() => const EngagementDepth(averageDepth: 0, maxDepth: 0, depthDistribution: []);

  final double averageDepth;
  final int maxDepth;
  final List<int> depthDistribution;

  const EngagementDepth({
    required this.averageDepth,
    required this.maxDepth,
    required this.depthDistribution,
  });
}

class MessagingHealthMetrics {
  static MessagingHealthMetrics empty() => const MessagingHealthMetrics(healthScore: 0, deliveryRate: 0, responseRate: 0, averageResponseTime: Duration.zero);

  final double healthScore;
  final double deliveryRate;
  final double responseRate;
  final Duration averageResponseTime;

  const MessagingHealthMetrics({
    required this.healthScore,
    required this.deliveryRate,
    required this.responseRate,
    required this.averageResponseTime,
  });
}

class NetworkGrowthMetrics {
  static NetworkGrowthMetrics empty() => const NetworkGrowthMetrics(healthScore: 0, growthRate: 0, connectionQuality: 0);

  final double healthScore;
  final double growthRate;
  final double connectionQuality;

  const NetworkGrowthMetrics({
    required this.healthScore,
    required this.growthRate,
    required this.connectionQuality,
  });
}

class ResponseTimeMetrics {
  static ResponseTimeMetrics empty() => const ResponseTimeMetrics(average: Duration.zero, median: Duration.zero, percentile95: Duration.zero);

  final Duration average;
  final Duration median;
  final Duration percentile95;

  const ResponseTimeMetrics({
    required this.average,
    required this.median,
    required this.percentile95,
  });
}

class HealthTrends {
  static HealthTrends empty() => const HealthTrends(direction: TrendDirection.stable, velocity: 0, predictions: []);

  final TrendDirection direction;
  final double velocity;
  final List<double> predictions;

  const HealthTrends({
    required this.direction,
    required this.velocity,
    required this.predictions,
  });
}

enum TrendDirection { improving, declining, stable }

// Event models
class ActivityEvent {
  final String userId;
  final DateTime timestamp;
  final String type;
  final Map<String, dynamic> data;

  const ActivityEvent({
    required this.userId,
    required this.timestamp,
    required this.type,
    required this.data,
  });
}

class ContentEvent {
  final String contentId;
  final String userId;
  final DateTime timestamp;
  final String type;
  final Map<String, dynamic> data;

  const ContentEvent({
    required this.contentId,
    required this.userId,
    required this.timestamp,
    required this.type,
    required this.data,
  });
}

class EngagementEvent {
  final String userId;
  final String contentId;
  final DateTime timestamp;
  final String type;
  final Map<String, dynamic> data;

  const EngagementEvent({
    required this.userId,
    required this.contentId,
    required this.timestamp,
    required this.type,
    required this.data,
  });
}

class FriendRequestEvent {
  final String fromUserId;
  final String toUserId;
  final DateTime timestamp;
  final String type;
  final Map<String, dynamic> data;

  const FriendRequestEvent({
    required this.fromUserId,
    required this.toUserId,
    required this.timestamp,
    required this.type,
    required this.data,
  });
}

class CriticalIssue {
  final String type;
  final String severity;
  final String description;
  final DateTime detectedAt;
  final Map<String, dynamic> data;

  const CriticalIssue({
    required this.type,
    required this.severity,
    required this.description,
    required this.detectedAt,
    required this.data,
  });
}
